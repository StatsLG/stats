<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CI Coverage Demo — StatsLG</title>
  <meta name="description" content="Visual demo of confidence-interval coverage with shared StatsLG sidebar and styling." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/style/bctcstyle.css">

  <!-- (optional) MathJax for pretty inline math in labels -->
  <script>
    window.MathJax = { tex:{ inlineMath:[['\\(','\\)'],['$','$']] } };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .viz-card{ padding:14px; }
    .controls{ display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap:12px; }
    .viz-wrap{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .viz{ width:100%; height:320px; min-height:320px; background:#fff; border:1px solid var(--rule); border-radius:12px }
    .viz-short{ height:360px; min-height:360px }
    .muted-small{ color:var(--muted); font-size:12px }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ===== Shared sidebar include (robust paths) ===== -->
    <aside class="sidebar" aria-label="Site navigation" data-include="partials/sidebar.html"></aside>

    <!-- ===== Main ===== -->
    <main>
      <header>
        <h1>Confidence Interval Coverage (Mean, z-interval)</h1>
        <p class="subtitle">
          Panel A: sample means stacked in rows vs band \( \mu \pm z^*\sigma/\sqrt{n} \).<br>
          Panel B: the same samples as intervals \( \bar x \pm z^*\sigma/\sqrt{n} \) with a single short dash marking \( \bar x \) and a reference line at \( \mu \).
        </p>
      </header>

      <section class="section">
        <div class="card viz-card">
          <div class="controls">
            <div class="card soft">
              <label>True mean \( \mu \)</label>
              <input id="mu" type="number" step="0.01" value="100">
              <label style="margin-top:8px;">Population SD \( \sigma \)</label>
              <input id="sigma" type="number" min="0.0001" step="0.0001" value="15">
            </div>
            <div class="card soft">
              <label>Sample size \( n \)</label>
              <input id="n" type="number" min="2" step="1" value="25">
              <label style="margin-top:8px;">Confidence level (%)</label>
              <input id="conf" type="number" min="50" max="99.9" step="0.1" value="95">
            </div>
            <div class="card soft">
              <label>Number of samples</label>
              <input id="nsamp" type="number" min="5" max="400" step="1" value="60">
              <div class="row" style="gap:8px; margin-top:8px;">
                <button class="btn" id="resample">Resample</button>
                <button class="btn ghost" id="step">Add 1</button>
              </div>
              <p class="muted-small" style="margin:.4rem 0 0;">
                Samples are generated as \( \bar X \sim \mathcal N(\mu,\; \sigma/\sqrt{n}) \) for speed.
              </p>
            </div>
            <div class="card soft">
              <div class="muted-small">Current settings</div>
              <div id="kSE" style="font-weight:800;">SE = —</div>
              <div id="kZstar" style="font-weight:800;">z* = —</div>
              <div id="kMargin" style="font-weight:800;">Margin = —</div>
              <div id="kCover" style="font-weight:800; margin-top:6px;">Coverage = —</div>
            </div>
          </div>

          <div class="viz-wrap">
            <svg id="panelA" class="viz" role="img" aria-label="Sample means vs acceptance band"></svg>
            <svg id="panelB" class="viz viz-short" role="img" aria-label="Confidence intervals by sample"></svg>
          </div>
        </div>
      </section>

      <footer>
        Last updated: <span id="lastUpdated"></span>
      </footer>
    </main>
  </div>

  <script>
    // ---------------- Sidebar include (robust for GitHub Pages) ----------------
    (async function injectSidebar(){
      const el = document.querySelector('[data-include]');
      if(!el) return;

      const given = el.getAttribute('data-include') || 'partials/sidebar.html';
      const firstSeg = location.pathname.split('/').filter(Boolean)[0] || '';
      const base = firstSeg ? ('/' + firstSeg) : '';

      const candidates = [
        given,
        '/' + given.replace(/^\//,''),
        base + '/' + given.replace(/^\//,''),
        base + '/partials/sidebar.html',
        '/partials/sidebar.html'
      ].filter((v,i,a)=>a.indexOf(v)===i);

      let html = '';
      for (const url of candidates){
        try{
          const r = await fetch(url, {cache:'no-cache'});
          if (r.ok) { html = await r.text(); break; }
        }catch(_){}
      }

      el.innerHTML = html || '<div class="muted">Sidebar failed to load.</div>';
      const yr = el.querySelector('#yr'); if (yr) yr.textContent = new Date().getFullYear();
    })();

    document.getElementById('lastUpdated').textContent = new Date(document.lastModified).toLocaleString();

    // ---------------- Normal CDF + robust inverse ----------------
    const SQRT2 = Math.SQRT2, SQRT2PI = Math.sqrt(2*Math.PI);
    function cdf(z){
      const sign = z < 0 ? -1 : 1;
      z = Math.abs(z)/SQRT2;
      const t = 1/(1+0.3275911*z);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
      const erf = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
      return 0.5*(1 + sign*erf);
    }
    function invnorm(p){
      if (p<=0) return -10;
      if (p>=1) return 10;
      let lo=-10, hi=10;
      for (let i=0;i<80;i++){
        const mid=(lo+hi)/2, cm=cdf(mid);
        if (cm<p) lo=mid; else hi=mid;
      }
      return (lo+hi)/2;
    }

    // ---------------- RNG (Box–Muller) ----------------
    function rnorm(mean=0, sd=1){
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      const z=Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
      return mean + sd*z;
    }

    // ---------------- Elements/State ----------------
    const muEl = document.getElementById('mu');
    const sigmaEl = document.getElementById('sigma');
    const nEl = document.getElementById('n');
    const confEl = document.getElementById('conf');
    const nsampEl = document.getElementById('nsamp');
    const resampleBtn = document.getElementById('resample');
    const stepBtn = document.getElementById('step');

    const kSE = document.getElementById('kSE');
    const kZstar = document.getElementById('kZstar');
    const kMargin = document.getElementById('kMargin');
    const kCover = document.getElementById('kCover');

    const svgA = document.getElementById('panelA');
    const svgB = document.getElementById('panelB');

    let sampleMeans = [];
    let cachedScale = null;

    function computeCore(){
      const mu = +muEl.value || 0;
      const sigma = Math.max(1e-9, +sigmaEl.value || 1);
      const n = Math.max(2, +nEl.value || 2);
      const conf = Math.max(50, Math.min(99.9, +confEl.value || 95));
      const alpha2 = (1 - conf/100)/2;
      const zstar = invnorm(1 - alpha2);
      const SE = sigma / Math.sqrt(n);
      const m = Math.max(1e-12, zstar*SE);
      return { mu, sigma, n, conf, zstar, SE, m };
    }

    function fmt(x,d=4){
      if (!isFinite(x)) return '—';
      const ax = Math.abs(x);
      if (ax>0 && (ax<1e-3 || ax>=1e6)) return x.toExponential(2);
      return x.toFixed(d);
    }

    function updateKPIs(core, coverageCount){
      kSE.textContent     = `SE = ${fmt(core.SE, 6)}`;
      kZstar.textContent  = `z* = ${fmt(core.zstar, 4)}`;
      kMargin.textContent = `Margin = ${fmt(core.m, 6)}`;
      const nS = sampleMeans.length;
      const txt = nS ? `${coverageCount}/${nS} cover (≈ ${(100*coverageCount/nS).toFixed(1)}%)` : '—';
      kCover.innerHTML = `Coverage = ${txt}`;
    }

    function clearSVG(svg){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
    function sizeSVG(svg, fallbackW=900, fallbackH=320){
      const rect = svg.getBoundingClientRect();
      const W = Math.round(rect.width || svg.clientWidth || fallbackW);
      const H = Math.round(rect.height || svg.clientHeight || fallbackH);
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      return {W,H};
    }

    function scaleX(core){
      if (!sampleMeans.length){
        const span = Math.max(4*core.SE, 1.5*core.m, 1);
        return {lo: core.mu - span, hi: core.mu + span};
      }
      let minX = Infinity, maxX = -Infinity;
      for (const x of sampleMeans){
        minX = Math.min(minX, x - core.m);
        maxX = Math.max(maxX, x + core.m);
      }
      if (!isFinite(minX) || !isFinite(maxX) || minX===maxX){
        const span = Math.max(4*core.SE, 1.5*core.m, 1);
        return {lo: core.mu - span, hi: core.mu + span};
      }
      const pad = 0.15*(maxX - minX || 1);
      return {lo: minX - pad, hi: maxX + pad};
    }

    // ---------------- Panel A: stacked means (rows) ----------------
    function drawPanelA(core){
      clearSVG(svgA);
      const {W,H} = sizeSVG(svgA, 900, 320);
      const m = {t:16, r:16, b:32, l:48};
      const w = W - m.l - m.r, h = H - m.t - m.b;

      cachedScale = scaleX(core);
      const {lo, hi} = cachedScale;
      if (!isFinite(lo) || !isFinite(hi) || hi<=lo){
        drawNoData(svgA, 'Waiting for samples…'); return;
      }
      const x = v => m.l + ( (v - lo)/(hi - lo) ) * w;

      // axis at bottom
      const axisY = m.t + h - 8;
      const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
      axis.setAttribute('x1', m.l); axis.setAttribute('x2', m.l+w);
      axis.setAttribute('y1', axisY); axis.setAttribute('y2', axisY);
      axis.setAttribute('stroke', '#111827'); svgA.appendChild(axis);

      // ticks
      const ticks = 6;
      for (let i=0;i<=ticks;i++){
        const v = lo + i*(hi-lo)/ticks;
        const tx = x(v);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', tx); line.setAttribute('x2', tx);
        line.setAttribute('y1', axisY-4); line.setAttribute('y2', axisY+4);
        line.setAttribute('stroke', '#111827'); svgA.appendChild(line);
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.setAttribute('x', tx); lab.setAttribute('y', axisY+16);
        lab.setAttribute('text-anchor','middle'); lab.setAttribute('font-size','11'); lab.setAttribute('fill','#4b5563');
        lab.textContent = fmt(v,2); svgA.appendChild(lab);
      }

      // μ line (full height)
      const muX = x(core.mu);
      const muLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      muLine.setAttribute('x1', muX); muLine.setAttribute('x2', muX);
      muLine.setAttribute('y1', m.t); muLine.setAttribute('y2', m.t+h);
      muLine.setAttribute('stroke', '#111827'); muLine.setAttribute('stroke-width', '2');
      svgA.appendChild(muLine);

      // acceptance band across full height
      const band = document.createElementNS('http://www.w3.org/2000/svg','rect');
      const x1 = x(core.mu - core.m), x2 = x(core.mu + core.m);
      band.setAttribute('x', Math.min(x1,x2));
      band.setAttribute('y', m.t+4);
      band.setAttribute('width', Math.max(1, Math.abs(x2 - x1)));
      band.setAttribute('height', h-8);
      band.setAttribute('fill', 'rgba(16,185,129,0.18)');
      band.setAttribute('stroke', '#10b981'); band.setAttribute('stroke-width', '1');
      svgA.appendChild(band);

      // stacked rows for means (align with Panel B)
      const n = sampleMeans.length;
      const rowH = 18;
      const maxRows = Math.floor((h-24)/rowH) || 1;
      let coverCount = 0;

      for (let i=0;i<n;i++){
        const xbar = sampleMeans[i];
        const covers = Math.abs(xbar - core.mu) <= core.m;
        if (covers) coverCount++;
        const yRow = m.t + 16 + (i % maxRows)*rowH;

        // dot for mean
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('cx', x(xbar)); dot.setAttribute('cy', yRow);
        dot.setAttribute('r', 4);
        dot.setAttribute('fill', covers ? '#10b981' : '#ef4444');
        dot.setAttribute('stroke', covers ? '#065f46' : '#7f1d1d');
        svgA.appendChild(dot);
      }

      const legend = document.createElementNS('http://www.w3.org/2000/svg','text');
      legend.setAttribute('x', m.l); legend.setAttribute('y', m.t - 2);
      legend.setAttribute('font-size','12'); legend.setAttribute('fill','#4b5563');
      legend.textContent = 'Panel A • Dots = sample means; inside green band → CI would cover μ';
      svgA.appendChild(legend);

      updateKPIs(core, coverCount);
    }

    function drawNoData(svg, msg){
      const {W,H} = sizeSVG(svg);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', W/2); t.setAttribute('y', H/2);
      t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','14'); t.setAttribute('fill','#4b5563');
      t.textContent = msg; svg.appendChild(t);
    }

    // ---------------- Panel B: intervals with one short dash at mean ----------------
    function drawPanelB(core){
      clearSVG(svgB);
      const {W,H} = sizeSVG(svgB, 900, 360);
      const m = {t:18, r:16, b:28, l:48};
      const w = W - m.l - m.r, h = H - m.t - m.b;

      const {lo, hi} = cachedScale || scaleX(core);
      if (!isFinite(lo) || !isFinite(hi) || hi<=lo){
        drawNoData(svgB, 'Waiting for samples…'); return;
      }
      const x = v => m.l + ( (v - lo)/(hi - lo) ) * w;

      // axis + ticks (top)
      const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
      axis.setAttribute('x1', m.l); axis.setAttribute('x2', m.l+w);
      axis.setAttribute('y1', m.t); axis.setAttribute('y2', m.t);
      axis.setAttribute('stroke', '#111827'); svgB.appendChild(axis);

      const ticks = 6;
      for (let i=0;i<=ticks;i++){
        const v = lo + i*(hi-lo)/ticks;
        const tx = x(v);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', tx); line.setAttribute('x2', tx);
        line.setAttribute('y1', m.t-4); line.setAttribute('y2', m.t+4);
        line.setAttribute('stroke', '#111827'); svgB.appendChild(line);
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.setAttribute('x', tx); lab.setAttribute('y', m.t-8);
        lab.setAttribute('text-anchor','middle'); lab.setAttribute('font-size','11'); lab.setAttribute('fill','#4b5563');
        lab.textContent = fmt(v,2); svgB.appendChild(lab);
      }

      // μ reference line (full height)
      const muX = x(core.mu);
      const muLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      muLine.setAttribute('x1', muX); muLine.setAttribute('x2', muX);
      muLine.setAttribute('y1', m.t); muLine.setAttribute('y2', m.t+h);
      muLine.setAttribute('stroke', '#111827'); muLine.setAttribute('stroke-width', '2');
      svgB.appendChild(muLine);
      const muLab = document.createElementNS('http://www.w3.org/2000/svg','text');
      muLab.setAttribute('x', muX+6); muLab.setAttribute('y', m.t+14);
      muLab.setAttribute('font-size','12'); muLab.setAttribute('fill', '#111827');
      muLab.textContent = 'μ (true)'; svgB.appendChild(muLab);

      // intervals stacked in rows (same layout as A)
      const n = sampleMeans.length;
      if (!n){ drawNoData(svgB, 'No samples yet'); return; }
      const rowH = 18;
      const maxRows = Math.floor((h-24)/rowH) || 1;

      for (let i=0;i<n;i++){
        const xbar = sampleMeans[i];
        const loCI = xbar - core.m, hiCI = xbar + core.m;
        const covers = (loCI <= core.mu && core.mu <= hiCI);
        const yRow = m.t + 20 + (i % maxRows)*rowH;

        // interval line (single solid line)
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', x(loCI)); line.setAttribute('x2', x(hiCI));
        line.setAttribute('y1', yRow); line.setAttribute('y2', yRow);
        line.setAttribute('stroke', covers ? '#10b981' : '#ef4444');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-linecap', 'round'); // smoother ends
        svgB.appendChild(line);

        // mean marker: SHORT HORIZONTAL DASH centered at xbar
        const dash = document.createElementNS('http://www.w3.org/2000/svg','line');
        const dashW = 10; // total length of the dash
        dash.setAttribute('x1', x(xbar) - dashW/2);
        dash.setAttribute('x2', x(xbar) + dashW/2);
        dash.setAttribute('y1', yRow); dash.setAttribute('y2', yRow);
        dash.setAttribute('stroke', '#00467f');
        dash.setAttribute('stroke-width', '3');
        dash.setAttribute('stroke-linecap', 'round');
        svgB.appendChild(dash);
      }

      const legend = document.createElementNS('http://www.w3.org/2000/svg','text');
      legend.setAttribute('x', m.l); legend.setAttribute('y', m.t - 12);
      legend.setAttribute('font-size','12'); legend.setAttribute('fill','#4b5563');
      legend.textContent = 'Panel B • Each bar is CI; short blue dash marks the sample mean';
      svgB.appendChild(legend);

      const covered = sampleMeans.reduce((acc,xbar)=>acc + ((Math.abs(xbar - core.mu)<=core.m)?1:0), 0);
      updateKPIs(core, covered);
    }

    function redraw(){
      const core = computeCore();
      drawPanelA(core);
      drawPanelB(core);
    }

    function resampleAll(){
      const core = computeCore();
      const R = Math.max(5, Math.min(400, +nsampEl.value || 60));
      const se = core.SE;
      sampleMeans = Array.from({length:R}, ()=> rnorm(core.mu, se));
      redraw();
    }
    function addOne(){
      const core = computeCore();
      sampleMeans.push(rnorm(core.mu, core.SE));
      redraw();
    }

    // Redraw helpers
    function drawNoData(svg, msg){
      const {W,H} = sizeSVG(svg);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', W/2); t.setAttribute('y', H/2);
      t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','14'); t.setAttribute('fill','#4b5563');
      t.textContent = msg; svg.appendChild(t);
    }

    // Wire inputs
    [muEl, sigmaEl, nEl, confEl, nsampEl].forEach(el=>{
      el.addEventListener('change', resampleAll);
      el.addEventListener('input', resampleAll);
    });
    resampleBtn.addEventListener('click', resampleAll);
    stepBtn.addEventListener('click', addOne);

    // Redraw on resize so width never 0
    const ro = new ResizeObserver(()=>redraw());
    ro.observe(document.body);

    // initial
    setTimeout(resampleAll, 0);
  </script>
</body>
</html>

