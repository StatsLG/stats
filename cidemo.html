<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CI Coverage Demo — StatsLG</title>
  <meta name="description" content="Visual demo of confidence-interval coverage with shared StatsLG sidebar and styling." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/style/bctcstyle.css">

  <!-- (optional) MathJax for pretty inline math in labels -->
  <script>
    window.MathJax = { tex:{ inlineMath:[['\\(','\\)'],['$','$']] } };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .viz-card{ padding:14px; }
    .controls{ display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap:12px; }
    .viz-wrap{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .viz{ width:100%; height:320px; background:#fff; border:1px solid var(--rule); border-radius:12px }
    .viz-short{ height:360px }
    .muted-small{ color:var(--muted); font-size:12px }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ===== Shared sidebar include ===== -->
    <aside class="sidebar" aria-label="Site navigation" data-include="/partials/sidebar.html"></aside>

    <!-- ===== Main ===== -->
    <main>
      <header>
        <h1>Confidence Interval Coverage (Mean, z-interval)</h1>
        <p class="subtitle">
          Panel A: sample means vs band \( \mu \pm z^*\sigma/\sqrt{n} \).<br>
          Panel B: the same samples as intervals \( \bar x \pm z^*\sigma/\sqrt{n} \) with a reference line at \( \mu \).
        </p>
      </header>

      <section class="section">
        <div class="card viz-card">
          <div class="controls">
            <div class="card soft">
              <label>True mean \( \mu \)</label>
              <input id="mu" type="number" step="0.01" value="100">
              <label style="margin-top:8px;">Population SD \( \sigma \)</label>
              <input id="sigma" type="number" min="0.0001" step="0.0001" value="15">
            </div>
            <div class="card soft">
              <label>Sample size \( n \)</label>
              <input id="n" type="number" min="2" step="1" value="25">
              <label style="margin-top:8px;">Confidence level (%)</label>
              <input id="conf" type="number" min="50" max="99.9" step="0.1" value="95">
            </div>
            <div class="card soft">
              <label>Number of samples</label>
              <input id="nsamp" type="number" min="5" max="400" step="1" value="60">
              <div class="row" style="gap:8px; margin-top:8px;">
                <button class="btn" id="resample">Resample</button>
                <button class="btn ghost" id="step">Add 1</button>
              </div>
              <p class="muted-small" style="margin:.4rem 0 0;">
                Samples are generated as \( \bar X \sim \mathcal N(\mu,\; \sigma/\sqrt{n}) \) for speed.
              </p>
            </div>
            <div class="card soft">
              <div class="muted-small">Current settings</div>
              <div id="kSE" style="font-weight:800;">SE = —</div>
              <div id="kZstar" style="font-weight:800;">z* = —</div>
              <div id="kMargin" style="font-weight:800;">Margin = —</div>
              <div id="kCover" style="font-weight:800; margin-top:6px;">Coverage = —</div>
            </div>
          </div>

          <div class="viz-wrap">
            <svg id="panelA" class="viz" role="img" aria-label="Sample means vs acceptance band"></svg>
            <svg id="panelB" class="viz viz-short" role="img" aria-label="Confidence intervals by sample"></svg>
          </div>
        </div>
      </section>

      <footer>
        Last updated: <span id="lastUpdated"></span>
      </footer>
    </main>
  </div>

  <script>
    // -------- shared sidebar include --------
    const BASE = ''; // set to '/REPO_NAME' for project sites
    (async function injectSidebar(){
      const el = document.querySelector('[data-include]');
      if(!el) return;
      let url = el.getAttribute('data-include') || '/partials/sidebar.html';
      if (BASE && url.startsWith('/')) url = BASE + url;
      try{
        const resp = await fetch(url, {cache:'no-cache'});
        el.innerHTML = await resp.text();
        const yr = el.querySelector('#yr'); if (yr) yr.textContent = new Date().getFullYear();
      }catch(e){
        el.innerHTML = '<div class="muted">Sidebar failed to load.</div>';
      }
    })();
    document.getElementById('lastUpdated').textContent = new Date(document.lastModified).toLocaleString();

    // -------- Robust normal CDF + inverse (binary search) --------
    const SQRT2 = Math.SQRT2, SQRT2PI = Math.sqrt(2*Math.PI);
    function pdf(z){ return Math.exp(-0.5*z*z)/SQRT2PI; }
    // erf approximation → CDF
    function cdf(z){
      const sign = z < 0 ? -1 : 1;
      z = Math.abs(z)/SQRT2;
      const t = 1/(1+0.3275911*z);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
      const erf = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
      return 0.5*(1 + sign*erf);
    }
    // Always-convergent inverse CDF (no NaNs)
    function invnorm(p){
      if (p<=0) return -10;
      if (p>=1) return 10;
      let lo=-10, hi=10;
      for (let i=0;i<80;i++){
        const mid=(lo+hi)/2, cmid=cdf(mid);
        if (cmid < p) lo = mid; else hi = mid;
      }
      return (lo+hi)/2;
    }

    // -------- RNG: normal via Box–Muller --------
    function rnorm(mean=0, sd=1){
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      const z=Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
      return mean + sd*z;
    }

    // -------- State + elements --------
    const muEl = document.getElementById('mu');
    const sigmaEl = document.getElementById('sigma');
    const nEl = document.getElementById('n');
    const confEl = document.getElementById('conf');
    const nsampEl = document.getElementById('nsamp');
    const resampleBtn = document.getElementById('resample');
    const stepBtn = document.getElementById('step');

    const kSE = document.getElementById('kSE');
    const kZstar = document.getElementById('kZstar');
    const kMargin = document.getElementById('kMargin');
    const kCover = document.getElementById('kCover');

    const svgA = document.getElementById('panelA');
    const svgB = document.getElementById('panelB');

    let sampleMeans = [];
    let cachedScale = null;

    function computeCore(){
      const mu = +muEl.value || 0;
      const sigma = Math.max(1e-9, +sigmaEl.value || 1);
      const n = Math.max(2, +nEl.value || 2);
      const conf = Math.max(50, Math.min(99.9, +confEl.value || 95));
      const alpha2 = (1 - conf/100)/2;
      const zstar = invnorm(1 - alpha2);        // robust
      const SE = sigma / Math.sqrt(n);
      const m = zstar * SE;
      return { mu, sigma, n, conf, zstar, SE, m };
    }

    function fmt(x,d=4){
      if (!isFinite(x)) return '—';
      const ax = Math.abs(x);
      if (ax>0 && (ax<1e-3 || ax>=1e6)) return x.toExponential(2);
      return x.toFixed(d);
    }

    function updateKPIs(core, coverageCount){
      kSE.textContent     = `SE = ${fmt(core.SE, 6)}`;
      kZstar.textContent  = `z* = ${fmt(core.zstar, 4)}`;
      kMargin.textContent = `Margin = ${fmt(core.m, 6)}`;
      const nS = sampleMeans.length;
      const txt = nS ? `${coverageCount}/${nS} cover (≈ ${(100*coverageCount/nS).toFixed(1)}%)` : '—';
      kCover.innerHTML = `Coverage = ${txt}`;
    }

    function clearSVG(svg){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
    function sizeSVG(svg, fallbackW=900, fallbackH=320){
      const rect = svg.getBoundingClientRect();
      const W = Math.round(rect.width || svg.clientWidth || fallbackW);
      const H = Math.round(rect.height || svg.clientHeight || fallbackH);
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      return {W,H};
    }

    function scaleX(core){
      if (!isFinite(core.m)) { // super-safe guard
        const span = 4*core.SE || 1;
        return {lo: core.mu - span, hi: core.mu + span};
      }
      if (sampleMeans.length===0){
        const span = Math.max(4*core.SE, 1.5*core.m);
        return {lo: core.mu - span, hi: core.mu + span};
      }
      let minX = Infinity, maxX = -Infinity;
      for (const x of sampleMeans){
        minX = Math.min(minX, x - core.m);
        maxX = Math.max(maxX, x + core.m);
      }
      const pad = 0.15*(maxX - minX || core.m || 1);
      return {lo: minX - pad, hi: maxX + pad};
    }

    function drawPanelA(core){
      clearSVG(svgA);
      const {W,H} = sizeSVG(svgA, 900, 320);
      const mrg = {t:16, r:16, b:32, l:48};
      const w = W - mrg.l - mrg.r, h = H - mrg.t - mrg.b;

      cachedScale = scaleX(core);
      const {lo, hi} = cachedScale;
      const x = v => mrg.l + ( (v - lo)/(hi - lo) ) * w;
      const y = t => mrg.t + t*h;

      // axis
      const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
      axis.setAttribute('x1', mrg.l); axis.setAttribute('x2', mrg.l+w);
      axis.setAttribute('y1', y(0.75)); axis.setAttribute('y2', y(0.75));
      axis.setAttribute('stroke', '#111827'); svgA.appendChild(axis);

      // ticks
      const ticks = 6;
      for (let i=0;i<=ticks;i++){
        const v = lo + i*(hi-lo)/ticks;
        const tx = x(v);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', tx); line.setAttribute('x2', tx);
        line.setAttribute('y1', y(0.74)); line.setAttribute('y2', y(0.76));
        line.setAttribute('stroke', '#111827'); svgA.appendChild(line);
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.setAttribute('x', tx); lab.setAttribute('y', y(0.76)+16);
        lab.setAttribute('text-anchor','middle'); lab.setAttribute('font-size','11'); lab.setAttribute('fill','#4b5563');
        lab.textContent = fmt(v,2);
        svgA.appendChild(lab);
      }

      // true mu
      const muLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      muLine.setAttribute('x1', x(core.mu)); muLine.setAttribute('x2', x(core.mu));
      muLine.setAttribute('y1', y(0.05)); muLine.setAttribute('y2', y(0.95));
      muLine.setAttribute('stroke', '#111827'); muLine.setAttribute('stroke-width', '2');
      svgA.appendChild(muLine);
      const muLab = document.createElementNS('http://www.w3.org/2000/svg','text');
      muLab.setAttribute('x', x(core.mu)); muLab.setAttribute('y', y(0.05)-6);
      muLab.setAttribute('text-anchor', 'middle'); muLab.setAttribute('font-size','12'); muLab.setAttribute('fill', '#111827');
      muLab.textContent = 'μ (true)'; svgA.appendChild(muLab);

      // acceptance band
      const band = document.createElementNS('http://www.w3.org/2000/svg','rect');
      band.setAttribute('x', x(core.mu - core.m));
      band.setAttribute('y', y(0.15));
      band.setAttribute('width', Math.max(1, x(core.mu + core.m) - x(core.mu - core.m)));
      band.setAttribute('height', Math.max(1, y(0.60)-y(0.15)));
      band.setAttribute('fill', 'rgba(16,185,129,0.20)');
      band.setAttribute('stroke', '#10b981');
      band.setAttribute('stroke-width', '1');
      svgA.appendChild(band);

      // dots
      let coverCount = 0;
      for (const xbar of sampleMeans){
        const inside = (Math.abs(xbar - core.mu) <= core.m);
        if (inside) coverCount++;
        const cx = x(xbar);
        const cy = y(0.75) - 6 - Math.random()*28;
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy);
        dot.setAttribute('r', 4);
        dot.setAttribute('fill', inside ? '#10b981' : '#ef4444');
        dot.setAttribute('stroke', inside ? '#065f46' : '#7f1d1d');
        svgA.appendChild(dot);
      }

      // legend
      const legend = document.createElementNS('http://www.w3.org/2000/svg','text');
      legend.setAttribute('x', mrg.l); legend.setAttribute('y', mrg.t - 2);
      legend.setAttribute('font-size','12'); legend.setAttribute('fill','#4b5563');
      legend.textContent = 'Panel A • Means inside the green band → CI would cover μ';
      svgA.appendChild(legend);

      updateKPIs(core, coverCount);
    }

    function drawPanelB(core){
      clearSVG(svgB);
      const {W,H} = sizeSVG(svgB, 900, 360);
      const mrg = {t:18, r:16, b:28, l:48};
      const w = W - mrg.l - mrg.r, h = H - mrg.t - mrg.b;

      const {lo, hi} = cachedScale || scaleX(core);
      const x = v => mrg.l + ( (v - lo)/(hi - lo) ) * w;

      // axis
      const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
      axis.setAttribute('x1', mrg.l); axis.setAttribute('x2', mrg.l+w);
      axis.setAttribute('y1', mrg.t); axis.setAttribute('y2', mrg.t);
      axis.setAttribute('stroke', '#111827'); svgB.appendChild(axis);

      // ticks
      const ticks = 6;
      for (let i=0;i<=ticks;i++){
        const v = lo + i*(hi-lo)/ticks;
        const tx = x(v);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', tx); line.setAttribute('x2', tx);
        line.setAttribute('y1', mrg.t-4); line.setAttribute('y2', mrg.t+4);
        line.setAttribute('stroke', '#111827'); svgB.appendChild(line);
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.setAttribute('x', tx); lab.setAttribute('y', mrg.t-8);
        lab.setAttribute('text-anchor','middle'); lab.setAttribute('font-size','11'); lab.setAttribute('fill','#4b5563');
        lab.textContent = fmt(v,2); svgB.appendChild(lab);
      }

      // mu reference
      const muLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      muLine.setAttribute('x1', x(computeCore().mu)); muLine.setAttribute('x2', x(computeCore().mu));
      muLine.setAttribute('y1', mrg.t); muLine.setAttribute('y2', mrg.t+h);
      muLine.setAttribute('stroke', '#111827'); muLine.setAttribute('stroke-width', '2');
      svgB.appendChild(muLine);
      const muLab = document.createElementNS('http://www.w3.org/2000/svg','text');
      muLab.setAttribute('x', x(computeCore().mu)+6); muLab.setAttribute('y', mrg.t+14);
      muLab.setAttribute('font-size','12'); muLab.setAttribute('fill','#111827');
      muLab.textContent = 'μ (true)'; svgB.appendChild(muLab);

      // intervals
      const n = sampleMeans.length;
      if (!n) return;
      const rowH = 18;
      const maxRows = Math.floor(h/rowH) || 1;

      for (let i=0;i<n;i++){
        const xbar = sampleMeans[i];
        const loCI = xbar - core.m, hiCI = xbar + core.m;
        const covers = (loCI <= core.mu && core.mu <= hiCI);
        const yRow = mrg.t + 20 + (i % maxRows)*rowH;

        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', x(loCI)); line.setAttribute('x2', x(hiCI));
        line.setAttribute('y1', yRow); line.setAttribute('y2', yRow);
        line.setAttribute('stroke', covers ? '#10b981' : '#ef4444');
        line.setAttribute('stroke-width', '4'); svgB.appendChild(line);

        const mid = document.createElementNS('http://www.w3.org/2000/svg','line');
        mid.setAttribute('x1', x(xbar)); mid.setAttribute('x2', x(xbar));
        mid.setAttribute('y1', yRow-6); mid.setAttribute('y2', yRow+6);
        mid.setAttribute('stroke', '#00467f'); mid.setAttribute('stroke-width', '2');
        svgB.appendChild(mid);
      }

      const legend = document.createElementNS('http://www.w3.org/2000/svg','text');
      legend.setAttribute('x', mrg.l); legend.setAttribute('y', mrg.t - 12);
      legend.setAttribute('font-size','12'); legend.setAttribute('fill','#4b5563');
      legend.textContent = 'Panel B • Intervals — green cover μ, red miss μ';
      svgB.appendChild(legend);

      // recompute count for KPI
      const covered = sampleMeans.reduce((acc,xbar)=>acc + ((Math.abs(xbar - core.mu)<=core.m)?1:0), 0);
      updateKPIs(core, covered);
    }

    function redraw(){
      const core = computeCore();
      drawPanelA(core);
      drawPanelB(core);
    }

    function resampleAll(){
      const core = computeCore();
      const R = Math.max(5, Math.min(400, +nsampEl.value || 60));
      const se = core.SE;
      sampleMeans = [];
      for (let i=0;i<R;i++){
        sampleMeans.push(rnorm(core.mu, se));
      }
      redraw();
    }
    function addOne(){
      const core = computeCore();
      sampleMeans.push(rnorm(core.mu, core.SE));
      redraw();
    }

    // Wire inputs
    [muEl, sigmaEl, nEl, confEl, nsampEl].forEach(el=>{
      el.addEventListener('change', resampleAll);
      el.addEventListener('input', resampleAll);
    });
    resampleBtn.addEventListener('click', resampleAll);
    stepBtn.addEventListener('click', addOne);

    // Redraw on resize (so width is never 0)
    const ro = new ResizeObserver(()=>redraw());
    ro.observe(document.body);

    // initial
    resampleAll();
  </script>
</body>
</html>
