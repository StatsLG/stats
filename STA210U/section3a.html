<!-- === 3-Coin Tree Diagram (drop-in section) === -->
<section id="tree-3-coins" class="section">
  <h2>Tree Diagram — 3 Coins</h2>
  <div class="card soft">
    <div class="row" style="align-items:center; gap:12px;">
      <div class="checkline">
        <input id="hl-2tails" type="checkbox">
        <label for="hl-2tails" style="margin:0;">Highlight “exactly 2 tails” (HTT, THT, TTH)</label>
      </div>
      <div class="checkline">
        <input id="hl-1tail" type="checkbox">
        <label for="hl-1tail" style="margin:0;">Highlight “exactly 1 tail” (HHT, HTH, THH)</label>
      </div>
    </div>

    <div class="preview" style="height:480px; margin-top:10px;">
      <svg id="coinTree" width="100%" height="100%" role="img" aria-label="Tree diagram for three coin flips"></svg>
    </div>

    <p class="muted" style="margin:.6rem 0 0;">
      Each edge has probability <span class="mono">1/2</span>. Each leaf (sequence) has probability <span class="mono">1/8</span>.
      There are 3 sequences with exactly 2 tails ⇒ \(P(\text{exactly 2 tails})=3/8\).
    </p>
  </div>
</section>

<script>
(function(){
  const svg = document.getElementById('coinTree');
  const HL2 = document.getElementById('hl-2tails');
  const HL1 = document.getElementById('hl-1tail');

  const NS = 'http://www.w3.org/2000/svg';
  function S(tag, attrs={}){ const el = document.createElementNS(NS, tag); for (const k in attrs) el.setAttribute(k, attrs[k]); return el; }

  function clear(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

  // Build all sequences for 3 flips
  function buildTree(){
    const leaves = [];
    const gen = (seq, depth) => {
      if (depth===3){ leaves.push(seq); return; }
      gen(seq+'H', depth+1);
      gen(seq+'T', depth+1);
    };
    gen('',0);
    return leaves; // length 8
  }

  // Compute layout: x by depth, y equally spaced for leaves; internal nodes centered over their children.
  function layout(leaves){
    const W = svg.clientWidth || svg.getBoundingClientRect().width || 900;
    const H = svg.clientHeight || svg.getBoundingClientRect().height || 480;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const margins = {t: 24, r: 24, b: 28, l: 80};
    const plotW = W - margins.l - margins.r;
    const plotH = H - margins.t - margins.b;

    // x positions per depth (0..3)
    const x = d => margins.l + (plotW * d / 3);

    // y positions for leaves (8 rows)
    const rows = 8;
    const rowGap = plotH / (rows-1);
    const leafY = i => margins.t + i * rowGap;

    // map from sequence prefix to y: leaves fixed; internal nodes average their children
    const yMap = {};
    // leaves y
    leaves.forEach((seq,i)=> yMap[seq] = leafY(i));

    // internal nodes (depth 0..2): compute in reverse by averaging children
    const prefixes = ['', 'H','T', 'HH','HT','TH','TT'];
    prefixes.reverse().forEach(pref=>{
      if (pref.length<3){
        const y1 = yMap[pref+'H'];
        const y2 = yMap[pref+'T'];
        yMap[pref] = (y1 + y2)/2;
      }
    });

    return { x, yMap, W, H, margins };
  }

  function labelText(x, y, text, opts={}){
    const t = S('text', {x, y, 'font-size': opts.size||12, 'text-anchor': opts.anchor||'middle', fill: opts.fill||'#4b5563'});
    t.textContent = text; return t;
  }

  function draw(){
    clear();
    const leaves = buildTree();
    const L = layout(leaves);

    // Title on left
    svg.appendChild(labelText(8, 16, 'Root → 3 flips → 8 outcomes', {anchor:'start', size:12}));

    // Draw edges + edge labels
    const strokeEdge = '#374151';
    const strokeHL   = '#10b981';
    const strokeMiss = '#ef4444';

    const nodeRadius = 10;

    // Helper: draw one edge with optional label (H/T)
    function edge(x1,y1,x2,y2, lab){
      const line = S('line', {x1,y1,x2,y2, stroke: strokeEdge, 'stroke-width': 2});
      svg.appendChild(line);

      // label midpoint slightly offset
      const mx = (x1+x2)/2, my = (y1+y2)/2;
      const t = labelText(mx, my - 6, lab, {size:11});
      svg.appendChild(t);

      // probability label 1/2 under branch
      const pt = labelText(mx, my + 12, '1/2', {size:10});
      svg.appendChild(pt);
    }

    // Draw edges depth by depth
    const levels = [
      { parents: [''], children: ['H','T'] },
      { parents: ['H','T'], children: ['HH','HT','TH','TT'] },
      { parents: ['HH','HT','TH','TT'], children: ['HHH','HHT','HTH','HTT','THH','THT','TTH','TTT'] }
    ];

    levels.forEach((lv, di)=>{
      lv.parents.forEach(p=>{
        const yParent = L.yMap[p];
        const xParent = L.x(di);
        // two children for each parent
        [['H', 'H'], ['T','T']].forEach(([branch, lab])=>{
          const child = p + branch;
          const yChild = L.yMap[child];
          const xChild = L.x(di+1);
          edge(xParent, yParent, xChild, yChild, lab);
        });
      });
    });

    // Draw nodes (root + internal)
    const allNodes = ['', 'H','T', 'HH','HT','TH','TT'];
    allNodes.forEach((id, d)=>{
      const cx = L.x(id.length);
      const cy = L.yMap[id];
      const c = S('circle', {cx, cy, r: nodeRadius, fill:'#ffffff', stroke:'#111827', 'stroke-width':2});
      svg.appendChild(c);
      const lab = id==='' ? 'Start' : id;
      svg.appendChild(labelText(cx, cy+4, lab||'Start', {size:11}));
    });

    // Draw leaves (sequences + p=1/8)
    leaves.forEach((seq,i)=>{
      const cx = L.x(3);
      const cy = L.yMap[seq];
      const covers2T = (seq.match(/T/g)||[]).length === 2;
      const covers1T = (seq.match(/T/g)||[]).length === 1;

      // small rounded rect for leaf tag
      const rx = 28, ry = 10;
      const rect = S('rect', {
        x: cx - rx, y: cy - ry, width: rx*2, height: ry*2, rx: 8, ry: 8,
        fill: '#ffffff', stroke: '#111827', 'stroke-width': 1.5
      });
      svg.appendChild(rect);

      const color2 = '#065f46', fill2 = '#10b981';
      const color1 = '#1e40af', fill1 = '#60a5fa';

      if (HL2.checked && covers2T){
        rect.setAttribute('fill', fill2);
        rect.setAttribute('stroke', color2);
      }else if (HL1.checked && covers1T){
        rect.setAttribute('fill', fill1);
        rect.setAttribute('stroke', color1);
      }

      const t = labelText(cx, cy+4, seq, {size:12, fill:'#111827'});
      svg.appendChild(t);

      const p = labelText(cx + 48, cy+4, '1/8', {size:11});
      svg.appendChild(p);
    });

    // Legend bullets (only when highlighting)
    const showLegend = HL2.checked || HL1.checked;
    if (showLegend){
      const baseX = L.W - 160, baseY = 28;
      const legend = S('g', {});
      svg.appendChild(legend);

      if (HL2.checked){
        const r = S('rect', {x: baseX, y: baseY, width: 14, height: 14, rx:3, ry:3, fill:'#10b981', stroke:'#065f46'});
        const tx = labelText(baseX+20, baseY+11, 'Exactly 2 tails', {anchor:'start', size:12, fill:'#111827'});
        legend.appendChild(r); legend.appendChild(tx);
      }
      if (HL1.checked){
        const off = HL2.checked ? 20 : 0;
        const r = S('rect', {x: baseX, y: baseY+off, width: 14, height: 14, rx:3, ry:3, fill:'#60a5fa', stroke:'#1e40af'});
        const tx = labelText(baseX+20, baseY+off+11, 'Exactly 1 tail', {anchor:'start', size:12, fill:'#111827'});
        legend.appendChild(r); legend.appendChild(tx);
      }
    }
  }

  // Initial draw + listeners
  draw();
  HL2.addEventListener('change', draw);
  HL1.addEventListener('change', draw);
  // Redraw on resize for responsive sizing
  const ro = new ResizeObserver(()=>draw());
  ro.observe(document.body);
})();
</script>
