<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Central Limit Theorem Demo — StatsLG</title>
  <link rel="stylesheet" href="/style/bctcstyle.css">
  <link rel="icon" href="/favicon.ico"/>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>

  <style>
    .wrap-grid{display:flex;gap:1rem;align-items:flex-start}
    .panel{background:var(--panel);border:1px solid var(--rule);border-radius:.75rem;padding:1rem}
    .controls{width:300px;}
    .sl{width:100%}
    .tabs{display:flex;gap:.5rem;margin-bottom:.75rem}
    .tab{padding:.4rem .8rem;border:1px solid var(--rule);border-bottom:none;border-radius:.5rem .5rem 0 0;background:var(--panel);cursor:pointer}
    .tab.active{background:var(--card);font-weight:600}
    .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:.4rem;margin-top:.5rem}
    .stats div{background:var(--panel);border:1px solid var(--rule);padding:.4rem;border-radius:.4rem;text-align:center}
    .canvas-wrap{position:relative;height:460px;}
    #dotCanvas{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    table{width:100%;border-collapse:collapse;margin-top:.5rem}
    th,td{border:1px solid var(--rule);padding:.35rem;text-align:right}
    th{text-align:center;background:var(--panel)}
    button{width:100%;margin-top:.4rem}
  </style>
</head>
<body>

<div class="wrap">
  <aside class="sidebar" data-include="/partials/sidebar.html"></aside>
  <main>

    <h1>Central Limit Theorem Demo</h1>
    <p class="subtitle">Compare the <b>Population</b> distribution (ghost curve) to the <b>Sampling Distribution</b> forming below.</p>

    <div class="tabs">
      <button class="tab active" id="tabMeans">Sample Means</button>
      <button class="tab" id="tabProps">Sample Proportions</button>
    </div>

    <section class="panel">
      <div class="wrap-grid">

        <!-- LEFT CONTROL PANEL -->
        <div class="panel controls">

          <div id="meansControls">
            <label><b>Population Shape</b></label><br>
            <select id="shape">
              <option value="uniform">Uniform</option>
              <option value="normal" selected>Normal</option>
              <option value="lognormal">Skewed (Lognormal)</option>
              <option value="bimodal">Bimodal</option>
              <option value="crazy">Crazy Mix</option>
            </select>

            <br><br>
            <label>Sample Size (n)</label>
            <input type="range" id="nMeans" class="sl" min="2" max="500" value="30">
            <div>n = <span id="nMeansVal">30</span></div>
          </div>

          <div id="propsControls" style="display:none;">
            <label>True proportion p</label>
            <input type="range" id="trueP" class="sl" min="0" max="1" step="0.01" value="0.35">
            <div>p = <span id="truePVal">0.35</span></div>

            <label>Sample Size (n)</label>
            <input type="range" id="nProps" class="sl" min="2" max="1000" value="50">
            <div>n = <span id="nPropsVal">50</span></div>
          </div>

          <hr>
          <div class="stats">
            <div>μ: <span id="popMean">--</span></div>
            <div>σ: <span id="popSD">--</span></div>
            <div>σ/√n: <span id="sampSD">--</span></div>
            <div>Samples: <span id="countSamples">0</span></div>
          </div>

          <hr>

          <button id="add1">Add 1 (dot)</button>
          <button id="add50">Add 50 (animated)</button>
          <button id="add1000">Add 1000 (no animation)</button>
          <button id="reset">Reset</button>
        </div>

        <!-- RIGHT PANEL -->
        <div class="panel" style="flex-grow:1;">
          <div class="canvas-wrap">
            <canvas id="hist"></canvas>
            <canvas id="dotCanvas"></canvas>
          </div>

          <h3>Frequency Table</h3>
          <div id="freq"></div>
        </div>

      </div>
    </section>

  </main>
</div>

<script>
document.querySelectorAll('[data-include]').forEach(el=>fetch(el.dataset.include).then(r=>r.text()).then(h=>el.innerHTML=h));

let mode="means";
let sampleStats=[];
let bins=60;
let domain=[-5,5];
let population=[];

const ctx = document.getElementById("hist").getContext("2d");
const dotCtx = document.getElementById("dotCanvas").getContext("2d");

function mean(a){return a.reduce((x,y)=>x+y,0)/a.length;}
function sd(a){let m=mean(a),s=0;for(let v of a)s+=(v-m)**2;return Math.sqrt(s/(a.length-1));}

// Generate population dataset
function genPop(){
  if(mode==="props") return;
  let N=80000,p=[];
  let shape=document.getElementById("shape").value;
  for(let i=0;i<N;i++){
    if(shape==="uniform") p.push(Math.random());
    else if(shape==="normal") p.push((Math.random()*1));
    else if(shape==="lognormal") p.push(Math.exp(Math.random()*1));
    else if(shape==="bimodal") p.push(Math.random()<.5?Math.random()*0.5:Math.random()*0.5+1.5);
    else p.push((Math.random()<.7?(Math.random()*-Math.log(Math.random())):((Math.random()*0.3)-2)));
  }
  population=p;
}

// KDE for population ghost curve
function kde(values, xs){
  let s=sd(values), bw=s*0.4, k=t=>Math.exp(-0.5*t*t)/Math.sqrt(2*Math.PI);
  return xs.map(x=>mean(values.map(v=>k((x-v)/bw)))/bw);
}

// Chart with two datasets
let chart=new Chart(ctx,{
  type:"bar",
  data:{
    labels:[],
    datasets:[
      { data:[], backgroundColor:"#00467f" },
      { data:[], type:"line", borderColor:"rgba(0,70,127,0.60)", borderWidth:2, tension:0.4, pointRadius:0, fill:false }
    ]
  },
  options:{
    animation:false,
    maintainAspectRatio:false,
    scales:{x:{type:"linear"},y:{beginAtZero:true}}
  }
});

// Refresh sampling histogram & ghost curve
function refresh(){
  let center=(sampleStats.length>0)?mean(sampleStats):(mode==="props"?parseFloat(trueP.value):mean(population));
  let spread=(mode==="props"
    ? Math.sqrt((parseFloat(trueP.value)*(1-parseFloat(trueP.value))))/Math.sqrt(nProps.value)
    : sd(population)/Math.sqrt(nMeans.value)
  );

  let lo=center-4*spread, hi=center+4*spread;
  domain=[lo,hi];

  let w=(hi-lo)/bins;
  let edges=Array.from({length:bins+1},(_,i)=>lo+i*w);
  let counts=Array(bins).fill(0);

  for(let v of sampleStats){
    if(v>=lo && v<=hi){
      let i=Math.floor((v-lo)/w); if(i>=bins)i=bins-1;
      counts[i]++;
    }
  }

  chart.data.labels=edges.slice(0,-1);
  chart.data.datasets[0].data=counts;

  // Population ghost curve
  if(mode==="means"){
    let xs = edges;
    let density = kde(population, xs);
    let maxCount = Math.max(...counts,1);
    let maxD = Math.max(...density,1);
    let scaled = density.map(d=> d/maxD * maxCount);
    chart.data.datasets[1].data = xs.map((x,i)=>({x, y: scaled[i]||0}));
  } else {
    chart.data.datasets[1].data = [];
  }

  chart.options.scales.x.min=lo;
  chart.options.scales.x.max=hi;
  chart.options.scales.y.max=Math.max(5,...counts)*1.2;
  chart.update("none");

  freq.innerHTML="<table><tr><th>Range</th><th>Count</th></tr>"+
    counts.map((c,i)=>`<tr><td>${edges[i].toFixed(3)} to ${edges[i+1].toFixed(3)}</td><td>${c}</td></tr>`).join("")+
    "</table>";
  popMean.textContent=(mode==="props"?parseFloat(trueP.value):mean(population)).toFixed(4);
  popSD.textContent=(mode==="props"?Math.sqrt(parseFloat(trueP.value)*(1-parseFloat(trueP.value))):sd(population)).toFixed(4);
  sampSD.textContent=(spread).toFixed(6);
  countSamples.textContent=sampleStats.length;
}

// Falling dot animation
function dot(value){
  let xs=chart.scales.x, ys=chart.scales.y;
  let x=xs.getPixelForValue(value), y=ys.getPixelForValue(0);
  let start=0,end=y-6,t0=performance.now();
  function f(t){
    let p=Math.min(1,(t-t0)/300),e=1-(1-p)**3;
    dotCtx.clearRect(0,0,dotCanvas.width,dotCanvas.height);
    dotCtx.beginPath(); dotCtx.arc(x,start+(end-start)*e,5,0,7); dotCtx.fillStyle="#d9534f"; dotCtx.fill();
    if(p<1)requestAnimationFrame(f);
  }
  requestAnimationFrame(f);
}

function drawSample(){
  if(mode==="props"){
    let p=parseFloat(trueP.value),n=parseInt(nProps.value),s=0;
    for(let i=0;i<n;i++) s+=(Math.random()<p?1:0);
    return s/n;
  } else {
    let n=parseInt(nMeans.value),s=0;
    for(let i=0;i<n;i++) s+=population[(Math.random()*population.length)|0];
    return s/n;
  }
}

function add(k,animate){
  for(let i=0;i<k;i++){
    let v=drawSample();
    sampleStats.push(v);
    if(i===k-1 && animate) { refresh(); dot(v); }
  }
  if(!animate) refresh();
}

add1.onclick=()=>add(1,true);
add50.onclick=()=>{let c=0;let I=setInterval(()=>{add(1,true);if(++c>=50)clearInterval(I)},120);}
add1000.onclick=()=>add(1000,false);
reset.onclick=()=>{sampleStats=[];refresh();dotCtx.clearRect(0,0,9999,9999)};

tabMeans.onclick=()=>{mode="means";tabMeans.classList.add("active");tabProps.classList.remove("active");meansControls.style.display="";propsControls.style.display="none";genPop();sampleStats=[];refresh();}
tabProps.onclick=()=>{mode="props";tabProps.classList.add("active");tabMeans.classList.remove("active");meansControls.style.display="none";propsControls.style.display="";sampleStats=[];refresh();}
shape.onchange=()=>{genPop();sampleStats=[];refresh();}
nMeans.oninput=()=>{nMeansVal.textContent=nMeans.value;refresh();}
nProps.oninput=()=>{nPropsVal.textContent=nProps.value;refresh();}
trueP.oninput=()=>{truePVal.textContent=trueP.value;refresh();}

genPop(); refresh();
</script>
</body>
</html>
