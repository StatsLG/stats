<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STA220 — Sampling Designs: SRS vs Stratified vs Cluster</title>
  <meta name="description" content="Interactive applet demonstrating SRS, stratified sampling, and cluster sampling." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/style/bctcstyle.css">

  <!-- MathJax for equations -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']],
        processEscapes: true
      },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .viz {
      width: 100%;
      height: 560px;
      border: 1px solid var(--rule);
      border-radius: var(--radius);
      background: #fff;
      display: block;
    }
    .legend { display:flex; flex-wrap:wrap; gap:8px; align-items:center }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--rule); border-radius:999px; background:#fff; font-size:12px }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(0,0,0,.1) }
    .muter { color: var(--muted); font-size:12px }
    .grid2 { display:grid; grid-template-columns: repeat(auto-fit,minmax(240px,1fr)); gap:12px }
    .mini { font-size: 12px; color: var(--muted); }
    .scroll-mini { max-height: 260px; overflow:auto; background:#fff; border:1px solid var(--rule); border-radius:8px; }
    .tight-table th, .tight-table td { font-size:12px; padding:4px 6px; }

    .stack { display:grid; gap:12px; }
    .pop-card .viz{
      height: min(78vh, 900px);
      width: 100%;
    }

    .pop-controls{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--rule);
      align-items: end;
    }
    .pop-controls .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pop-controls input[type="number"], .pop-controls select { width: 100%; }

    .pop-toggles{
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--rule);
      align-items:center;
    }
    .pop-toggles .checkline{ margin:0; }

    /* ============================================================
       FIX: force real checkbox / radio boxes (override bctcstyle.css)
       ============================================================ */
    .pop-toggles input[type="checkbox"],
    .pop-toggles input[type="radio"],
    .pop-controls input[type="checkbox"],
    .pop-controls input[type="radio"]{
      appearance: auto !important;
      -webkit-appearance: auto !important;
      width: 16px !important;
      height: 16px !important;
      padding: 0 !important;
      margin: 0 8px 0 0 !important;
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
      display: inline-block !important;
      vertical-align: middle !important;
      flex: 0 0 auto !important;
      accent-color: var(--kctcs-blue);
    }
    .pop-toggles .checkline,
    .pop-controls .checkline{
      display:inline-flex !important;
      align-items:center !important;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ===== LEFT PANEL (BRAND SIDEBAR) ===== -->
    <aside class="sidebar" aria-label="Site navigation">
      <div class="brand">
        <div class="brand-logo" aria-hidden="true"></div>
        <div class="brand-title">BCTC Statistics Hub</div>
      </div>

      <div class="nav-section">
        <h3>Graphing</h3>
        <nav class="nav">
          <a href="/graphing/barchart.html">Bar Chart</a>
          <a href="/graphing/piechart.html">Pie / Donut</a>
          <a href="/graphing/histogram.html">Histogram</a>
          <a href="/graphing/boxplot.html">Box &amp; Whisker</a>
          <a href="/graphing/scatterplot.html">Scatter + Regression</a>
          <a href="/graphing/barchart2way.html">Grouped Bar</a>
        </nav>
      </div>

      <div class="divider" role="separator"></div>

      <div class="nav-section">
        <h3>Analysis</h3>
        <nav class="nav">
          <a href="/descriptive/summary.html">Descriptive Summary</a>
          <a href="/inference/onemean.html">One-Sample Mean Test</a>
        </nav>
      </div>

      <div class="divider" role="separator"></div>

      <div class="nav-section">
        <h3>Notes & Extras</h3>
        <nav class="nav">
          <a href="/STA210U/">STA 210U</a>
          <a href="/STA220/">STA 220</a>
          <a href="/STA296U/">STA 296U</a>
          <a href="/game/pathyfinder.html">Pathy Finder</a>
        </nav>
      </div>

      <div class="footer-note">
        © <span id="yr"></span> StatsLG - Luke Garnett
      </div>
    </aside>

    <!-- ===== RIGHT PANEL (MAIN CONTENT) ===== -->
    <main>
      <header>
        <h1>Sampling Methods: SRS vs Stratified vs Cluster</h1>
        <p>The population size is <strong>10,000</strong>, divided equally among the four groups.</p>
      </header>

      <section class="section wrap" style="grid-template-columns: 1fr;">
        <div class="panel pad">
          <div class="stack">

            <div class="card pop-card">
              <h3 style="margin-top:0;">Population</h3>
              <div class="muter">
                N=<span id="NLabel">—</span>; <span id="dimLabel">—</span>.
                Colors show <span id="legendLabel">Group</span>.
              </div>

              <div class="legend" id="legend" style="margin:8px 0;"></div>
              <svg id="viz" class="viz" viewBox="0 0 760 560" aria-label="Population grid visualization"></svg>

              <div class="pop-controls" aria-label="Sampling controls">
                <div>
                  <label for="designSel">Sampling Method</label>
                  <select id="designSel">
                    <option value="srs">Simple Random Sample (SRS)</option>
                    <option value="strat">Stratified Random Sample</option>
                    <option value="cluster">Cluster Sample</option>
                  </select>
                </div>

                <div id="nBox">
                  <label for="nInput">Sample size n <span class="muter">(SRS/Stratified)</span></label>
                  <input id="nInput" type="number" min="5" max="5000" value="400" />
                </div>

                <div id="strataBox">
                  <label for="SInput"># of strata (horizontal bands)</label>
                  <input id="SInput" type="number" min="2" max="20" value="4" />
                  <div class="checkline" style="margin-top:6px;">
                    <input type="radio" id="allocProp" name="alloc" value="prop" checked>
                    <label for="allocProp" style="margin:0;">Proportional allocation</label>
                  </div>
                  <div class="checkline">
                    <input type="radio" id="allocEqual" name="alloc" value="equal">
                    <label for="allocEqual" style="margin:0;">Equal \(n_h\)</label>
                  </div>
                </div>

                <div id="clusterBox">
                  <label>Number of clusters (rows × cols)</label>
                  <div class="row">
                    <div style="flex:1; min-width:120px;">
                      <input id="cRows" type="number" min="2" max="50" value="10" />
                      <div class="mini">cluster rows</div>
                    </div>
                    <div style="flex:1; min-width:120px;">
                      <input id="cCols" type="number" min="2" max="50" value="10" />
                      <div class="mini">cluster cols</div>
                    </div>
                  </div>

                  <div class="checkline" style="margin-top:8px;">
                    <input type="checkbox" id="wackyClusters" checked>
                    <label for="wackyClusters" style="margin:0;">
                      Wacky cluster <em>shapes</em> (but equal cluster sizes)
                    </label>
                  </div>

                  <label style="margin-top:6px;" for="KInput"># clusters to sample (K)</label>
                  <input id="KInput" type="number" min="1" max="2500" value="10" />
                  <p class="muter" style="margin:.4rem 0 0;">
                    Each cluster has the same size; sample size depends on how many clusters you pick.
                  </p>
                </div>

                <div>
                  <label>Actions</label>
                  <div class="row">
                    <button class="btn" id="btnResample">Re-sample</button>
                    <button class="btn outline" id="btnShuffle">Shuffle population</button>
                    <button class="btn ghost" id="btnDefaults">Reset defaults</button>
                  </div>
                </div>
              </div>

              <div class="pop-toggles" aria-label="Population display toggles">
                <div class="checkline">
                  <input type="checkbox" id="showGrid" checked>
                  <label for="showGrid" style="margin:0;">Show overlays (match current design)</label>
                </div>
                <div class="checkline">
                  <input type="checkbox" id="clusterBorders" checked>
                  <label for="clusterBorders" style="margin:0;">Show cluster borders (Cluster mode)</label>
                </div>
                <div class="checkline">
                  <input type="checkbox" id="highlightClusters" checked>
                  <label for="highlightClusters" style="margin:0;">Highlight selected clusters</label>
                </div>
              </div>
            </div>

            <div class="card">
              <h3 style="margin-top:0;">Numbers</h3>

              <div class="grid2">
                <div>
                  <p>Population mean \( \mu \): <strong><span id="popMean"></span></strong></p>
                  <p>Population SD \( \sigma \): <span id="popSD"></span></p>
                </div>
                <div>
                  <p>Sample size \( n \): <strong><span id="sampleN"></span></strong></p>
                  <p>Sample mean \( \bar y \): <strong><span id="sampMean"></span></strong></p>
                  <p>Error \( \bar y - \mu \): <strong><span id="err"></span></strong></p>
                </div>
              </div>

              <div style="margin-top:10px;">
                <h4 style="margin:0 0 6px;">
                  Sample composition by group <span class="mini">(population groups)</span>
                </h4>
                <div class="scroll-mini">
                  <table class="table tight-table" id="groupTable" aria-label="Sample counts by group">
                    <thead>
                      <tr>
                        <th>Group</th>
                        <th>Population \(N_g\)</th>
                        <th>Selected</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
                <p class="mini" id="groupTotals" style="margin-top:6px;"></p>
              </div>
            </div>

          </div>
        </div>
      </section>

      <footer class="site-footer">
        Last updated: <span id="lastUpdated"></span>
      </footer>
    </main>
  </div>

  <script>
    // Footer info
    document.getElementById('yr').textContent = new Date().getFullYear();
    document.getElementById('lastUpdated').textContent = new Date(document.lastModified).toLocaleString();

    // ====== Parameters & helpers ======
    const R = 100, C = 100;
    const N = R*C;
    document.getElementById('NLabel').textContent = String(N);
    document.getElementById('dimLabel').textContent = `${R}×${C}`;

    const viz = document.getElementById('viz');
    const fmt = (x,d=3)=> Number.isFinite(x) ? x.toFixed(d) : '—';
    const sum = a => a.reduce((s,v)=>s+v,0);
    const mean = a => sum(a)/a.length;
    const popVar = a => { const m=mean(a); return sum(a.map(v => (v-m)*(v-m)))/a.length; };
    const sd = a => Math.sqrt(popVar(a));
    const randn = (mu=0, sigma=1) => {
      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return mu + sigma * Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    };
    const choiceK = (arr,k) => {
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a.slice(0,k);
    };

    const palette = [
      '#e7a614', '#3b82f6', '#ef4444', '#10b981', '#a855f7',
      '#fb923c', '#22c55e', '#06b6d4', '#f43f5e', '#8b5cf6'
    ];

    // ====== Population / grouping ======
    let S = 4;                 // groups (bands)
    let clusterRows = 10, clusterCols = 10; // how many clusters (rows*cols)
    let units = [];            // [{id,r,c,y,group,clusterId}]
    let sampleSet = new Set();

    // For wacky clusters:
    // clusterMap[r][c] = clusterId (0..K-1)
    let clusterMap = null;
    let totalClusters = 100; // clusterRows*clusterCols
    let clusterSize = 100;   // N / totalClusters

    function make2D(rows, cols, fill=null){
      const a = new Array(rows);
      for(let r=0;r<rows;r++){
        a[r] = new Array(cols).fill(fill);
      }
      return a;
    }

    function randInt(n){ return Math.floor(Math.random()*n); }

    // Build equal-size, "wacky" (blob-like) clusters via seeded growth with a fixed quota per cluster
    function buildWackyEqualClusters(K){
      const quota = Math.floor(N / K);
      const map = make2D(R, C, -1);

      // pick K unique seed cells
      const used = new Set();
      const seeds = [];
      while(seeds.length < K){
        const r = randInt(R), c = randInt(C);
        const key = r*C + c;
        if(used.has(key)) continue;
        used.add(key);
        seeds.push([r,c]);
      }

      // per cluster state
      const size = new Array(K).fill(0);
      const frontier = new Array(K).fill(0).map(()=>[]);
      const inFrontier = new Array(K).fill(0).map(()=> new Set());

      function addFront(k, r, c){
        const key = r*C + c;
        if(inFrontier[k].has(key)) return;
        frontier[k].push([r,c]);
        inFrontier[k].add(key);
      }

      let unassigned = N;

      // init seeds
      for(let k=0;k<K;k++){
        const [r,c] = seeds[k];
        map[r][c] = k;
        size[k] = 1;
        unassigned--;
        addFront(k, r, c);
      }

      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

      function tryGrowOne(k){
        // attempt to claim 1 new cell for cluster k
        while(frontier[k].length){
          // random frontier cell
          const idx = randInt(frontier[k].length);
          const [r,c] = frontier[k][idx];

          // try random neighbor order
          for(let t=0;t<4;t++){
            const [dr,dc] = dirs[randInt(4)];
            const rr = r+dr, cc = c+dc;
            if(rr<0||rr>=R||cc<0||cc>=C) continue;
            if(map[rr][cc] !== -1) continue;
            // claim
            map[rr][cc] = k;
            size[k]++; unassigned--;
            addFront(k, rr, cc);
            // keep (r,c) as frontier (still useful)
            return true;
          }

          // no unassigned neighbors: remove from frontier
          frontier[k].splice(idx,1);
          inFrontier[k].delete(r*C + c);
        }
        return false;
      }

      // Round-robin growth until quotas met
      let safety = N * 20;
      while(unassigned > 0 && safety-- > 0){
        let progressed = false;

        for(let k=0;k<K;k++){
          if(size[k] >= quota) continue;
          if(tryGrowOne(k)) progressed = true;
        }

        if(progressed) continue;

        // If everyone is stuck, assign a random unassigned cell to any cluster with remaining quota
        // (this can create a "teleport" seed, but still keeps sizes equal)
        let rr=-1, cc=-1;
        for(let tries=0; tries<5000; tries++){
          const r = randInt(R), c = randInt(C);
          if(map[r][c] === -1){ rr=r; cc=c; break; }
        }
        if(rr===-1) break;

        let kPick = -1;
        for(let tries=0; tries<2000; tries++){
          const k = randInt(K);
          if(size[k] < quota){ kPick = k; break; }
        }
        if(kPick === -1) break;

        map[rr][cc] = kPick;
        size[kPick]++; unassigned--;
        addFront(kPick, rr, cc);
      }

      // If due to rounding quota doesn't cover all (shouldn't if N%K==0), fill leftover
      if(unassigned > 0){
        for(let r=0;r<R;r++){
          for(let c=0;c<C;c++){
            if(map[r][c] !== -1) continue;
            // find any cluster with room
            let kPick = size.findIndex(s=>s<quota);
            if(kPick === -1) kPick = 0;
            map[r][c] = kPick;
            size[kPick]++; unassigned--;
            if(unassigned<=0) break;
          }
          if(unassigned<=0) break;
        }
      }

      return map;
    }

    function buildPopulation(){
      units = [];

      // group bands (horizontal)
      const bandH = Math.floor(R / S);
      const boundaries = Array.from({length:S}, (_,s) => {
        const r0 = s*bandH;
        const r1 = (s===S-1) ? R-1 : (s+1)*bandH - 1;
        return {s, r0, r1};
      });

      const effects = Array.from({length:S}, (_,i)=> (i - (S-1)/2) * 8);
      const base = 50, noiseSD = 6;

      // cluster mapping
      totalClusters = clusterRows * clusterCols;
      clusterSize = Math.floor(N / totalClusters);

      const useWacky = document.getElementById('wackyClusters')?.checked ?? true;
      if(useWacky){
        clusterMap = buildWackyEqualClusters(totalClusters);
      } else {
        clusterMap = null;
      }

      // regular grid cluster id when not wacky (uniform blocks)
      const blockH = R / clusterRows;
      const blockW = C / clusterCols;

      for(let r=0;r<R;r++){
        const b = boundaries.find(b => r>=b.r0 && r<=b.r1);
        const g = b ? b.s : 0;

        for(let c=0;c<C;c++){
          const id = r*C + c;

          let clusterId;
          if(clusterMap){
            clusterId = clusterMap[r][c];
          } else {
            const rc = Math.min(Math.floor(r / blockH), clusterRows-1);
            const cc = Math.min(Math.floor(c / blockW), clusterCols-1);
            clusterId = rc*clusterCols + cc;
          }

          const y = base + effects[g] + randn(0, noiseSD);
          units.push({id, r, c, y, group: g, clusterId});
        }
      }
    }

    // ====== Sampling designs ======
    function sampleSRS(n){
      const ids = choiceK(units.map(u=>u.id), Math.min(n,N));
      return new Set(ids);
    }

    function stratAllocations(n, sizes, mode='prop'){
      const S = sizes.length;
      if(mode==='equal'){
        const base = Math.floor(n / S);
        let rem = n - base*S;
        const nh = Array(S).fill(base);
        let i=0; while(rem>0){ nh[i%S]++; i++; rem--; }
        return nh;
      } else {
        const raw = sizes.map(Nh => n * Nh / sum(sizes));
        const flo = raw.map(x => Math.floor(x));
        let rem = n - sum(flo);
        const fracIdx = raw.map((x,i)=>({i, f: x - flo[i]})).sort((a,b)=> b.f - a.f);
        for(let k=0;k<rem;k++) flo[fracIdx[k].i]++;
        return flo;
      }
    }

    function sampleStratified(n, mode='prop'){
      const groups = new Map(); // g -> ids
      units.forEach(u => {
        if(!groups.has(u.group)) groups.set(u.group, []);
        groups.get(u.group).push(u.id);
      });
      const sizes = Array.from(groups.values()).map(g=>g.length);
      const nh = stratAllocations(n, sizes, mode);
      const out = new Set();
      Array.from(groups.entries()).forEach(([g, arr], idx) => {
        const k = Math.min(nh[idx], arr.length);
        choiceK(arr, k).forEach(id => out.add(id));
      });
      return out;
    }

    function sampleCluster(K){
      const allClusters = Array.from(new Set(units.map(u => u.clusterId)));
      const chosen = choiceK(allClusters, Math.min(K, allClusters.length));
      const out = new Set(units.filter(u => chosen.includes(u.clusterId)).map(u => u.id));
      return out;
    }

    function chosenClustersFromSample(){
      const set = new Set();
      for(const u of units){
        if(sampleSet.has(u.id)) set.add(u.clusterId);
      }
      return set;
    }

    // ====== Group table (ALWAYS population groups) ======
    function updateGroupTable(){
      const tbody = document.querySelector('#groupTable tbody');
      const totalsEl = document.getElementById('groupTotals');

      const popCount = new Map();
      const selCount = new Map();

      for(const u of units){
        const key = u.group;
        popCount.set(key, (popCount.get(key)||0) + 1);
        if(sampleSet.has(u.id)){
          selCount.set(key, (selCount.get(key)||0) + 1);
        }
      }

      const keys = Array.from(popCount.keys()).sort((a,b)=>a-b);

      tbody.innerHTML = keys.map(k => `
        <tr>
          <td>Group ${k+1}</td>
          <td>${popCount.get(k)}</td>
          <td>${selCount.get(k) || 0}</td>
        </tr>
      `).join('');

      const totalSelected = Array.from(selCount.values()).reduce((s,v)=>s+v,0);
      totalsEl.textContent = `Selected total: ${totalSelected} of ${units.length} units`;
    }

    // ====== Drawing ======
    function drawClusterBoundaries(W, H, pad, cellW, cellH, chosenClusters, highlight){
      // Draw boundaries where neighboring cells have different clusterId.
      // For 100x100 this is totally fine (~20k segments).
      for(let r=0;r<R;r++){
        for(let c=0;c<C;c++){
          const u = units[r*C + c];
          const cid = u.clusterId;

          // right edge boundary
          if(c < C-1){
            const v = units[r*C + (c+1)];
            if(v.clusterId !== cid){
              const x = pad + (c+1)*cellW;
              const y1 = pad + r*cellH;
              const y2 = pad + (r+1)*cellH;

              const isSelEdge = highlight && (chosenClusters.has(cid) || chosenClusters.has(v.clusterId));
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', x);
              line.setAttribute('x2', x);
              line.setAttribute('y1', y1);
              line.setAttribute('y2', y2);
              line.setAttribute('stroke', '#000');
              line.setAttribute('stroke-width', isSelEdge ? '2.8' : '1.1');
              line.setAttribute('opacity', isSelEdge ? '1' : '0.45');
              viz.appendChild(line);
            }
          }

          // bottom edge boundary
          if(r < R-1){
            const v = units[(r+1)*C + c];
            if(v.clusterId !== cid){
              const y = pad + (r+1)*cellH;
              const x1 = pad + c*cellW;
              const x2 = pad + (c+1)*cellW;

              const isSelEdge = highlight && (chosenClusters.has(cid) || chosenClusters.has(v.clusterId));
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', x1);
              line.setAttribute('x2', x2);
              line.setAttribute('y1', y);
              line.setAttribute('y2', y);
              line.setAttribute('stroke', '#000');
              line.setAttribute('stroke-width', isSelEdge ? '2.8' : '1.1');
              line.setAttribute('opacity', isSelEdge ? '1' : '0.45');
              viz.appendChild(line);
            }
          }
        }
      }

      // outer border
      const border = document.createElementNS('http://www.w3.org/2000/svg','rect');
      border.setAttribute('x', pad);
      border.setAttribute('y', pad);
      border.setAttribute('width', W-2*pad);
      border.setAttribute('height', H-2*pad);
      border.setAttribute('fill', 'none');
      border.setAttribute('stroke', '#000');
      border.setAttribute('stroke-width', '1.2');
      border.setAttribute('opacity', '0.45');
      viz.appendChild(border);
    }

    function draw(){
      const showGrid = document.getElementById('showGrid').checked;
      const design = document.getElementById('designSel').value;
      const legendEl = document.getElementById('legend');
      const legendLabel = document.getElementById('legendLabel');

      viz.innerHTML = '';
      const W=760, H=560, pad=10;
      const cellW = (W - 2*pad) / C;
      const cellH = (H - 2*pad) / R;

      // legend — population groups
      legendEl.innerHTML = '';
      legendLabel.textContent = 'Group';
      for(let g=0;g<S;g++){
        const div = document.createElement('div');
        div.className = 'chip';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = palette[g % palette.length];
        div.appendChild(sw);
        div.appendChild(document.createTextNode('Group ' + (g+1)));
        legendEl.appendChild(div);
      }

      // cells — colored by GROUP
      for(const u of units){
        const fill = palette[u.group % palette.length];
        const x = pad + u.c * cellW;
        const y = pad + u.r * cellH;
        const selected = sampleSet.has(u.id);

        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', Math.max(0.25, cellW));
        rect.setAttribute('height', Math.max(0.25, cellH));
        rect.setAttribute('fill', fill);
        rect.setAttribute('stroke', selected ? '#000' : 'rgba(0,0,0,0.06)');
        rect.setAttribute('stroke-width', selected ? 1.6 : 0.5);
        rect.setAttribute('opacity', selected ? 1 : 0.92);
        viz.appendChild(rect);
      }

      if(showGrid){
        if(design === 'cluster'){
          const showBorders = document.getElementById('clusterBorders').checked;
          const highlight = document.getElementById('highlightClusters').checked;
          if(showBorders){
            const chosen = chosenClustersFromSample();
            drawClusterBoundaries(W, H, pad, cellW, cellH, chosen, highlight);
          }
        } else if(design === 'strat') {
          // horizontal band boundaries (for groups)
          const bandH = Math.floor(R / S);
          for(let s=1; s<S; s++){
            const y = pad + s*bandH*cellH;
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', pad);
            line.setAttribute('x2', W-pad);
            line.setAttribute('y1', y);
            line.setAttribute('y2', y);
            line.setAttribute('stroke', '#000');
            line.setAttribute('stroke-width', '1.5');
            line.setAttribute('stroke-dasharray', '6 6');
            viz.appendChild(line);
          }
        }
      }
    }

    // ====== Orchestration ======
    function resample(){
      const design = document.getElementById('designSel').value;
      const n = +document.getElementById('nInput').value;
      const mode = document.getElementById('allocEqual').checked ? 'equal' : 'prop';
      const K = +document.getElementById('KInput').value;

      if(design==='srs'){
        sampleSet = sampleSRS(n);
      }else if(design==='strat'){
        sampleSet = sampleStratified(n, mode);
      }else{
        sampleSet = sampleCluster(K);
      }

      const yPop = units.map(u=>u.y);
      const ySamp = units.filter(u=>sampleSet.has(u.id)).map(u=>u.y);
      document.getElementById('popMean').textContent = fmt(mean(yPop), 3);
      document.getElementById('popSD').textContent = fmt(sd(yPop), 3);
      document.getElementById('sampleN').textContent = String(ySamp.length);
      document.getElementById('sampMean').textContent = fmt(mean(ySamp), 3);
      document.getElementById('err').textContent = fmt(mean(ySamp) - mean(yPop), 3);

      draw();
      updateGroupTable();
    }

    function syncVisibility(){
      const design = document.getElementById('designSel').value;

      document.getElementById('strataBox').style.display = (design==='strat') ? 'block' : 'none';
      document.getElementById('clusterBox').style.display = (design==='cluster') ? 'block' : 'none';
      document.getElementById('nBox').style.display = (design!=='cluster') ? 'block' : 'none';

      const cb = document.getElementById('clusterBorders');
      const hc = document.getElementById('highlightClusters');
      cb.disabled = (design!=='cluster');
      hc.disabled = (design!=='cluster');
    }

    function bestClusterGrid(targetR, targetC, requireBlockDivisible){
      // Find (r,c) in [2..50] closest to (targetR,targetC)
      // such that totalClusters = r*c divides N.
      // If requireBlockDivisible, also require R%r==0 and C%c==0.
      let best = {r:targetR, c:targetC, score:1e18};

      for(let r=2;r<=50;r++){
        for(let c=2;c<=50;c++){
          const K = r*c;
          if(N % K !== 0) continue;
          if(requireBlockDivisible){
            if(R % r !== 0) continue;
            if(C % c !== 0) continue;
          }
          const score = Math.abs(r-targetR) + Math.abs(c-targetC);
          if(score < best.score){
            best = {r, c, score};
          }
        }
      }
      return best;
    }

    function clampLayouts(){
      S = Math.max(2, Math.min(20, +document.getElementById('SInput').value||4));

      clusterRows = Math.max(2, Math.min(50, +document.getElementById('cRows').value||10));
      clusterCols = Math.max(2, Math.min(50, +document.getElementById('cCols').value||10));

      const wacky = document.getElementById('wackyClusters').checked;

      // If wacky: only need N divisible by (#clusters)
      // If not wacky: also need R%rows==0 and C%cols==0 so blocks align cleanly
      const best = bestClusterGrid(clusterRows, clusterCols, !wacky);

      clusterRows = best.r;
      clusterCols = best.c;

      document.getElementById('cRows').value = clusterRows;
      document.getElementById('cCols').value = clusterCols;

      // update KInput max whenever cluster grid changes
      totalClusters = clusterRows * clusterCols;
      document.getElementById('KInput').max = String(totalClusters);
      if(+document.getElementById('KInput').value > totalClusters){
        document.getElementById('KInput').value = String(Math.min(10, totalClusters));
      }
    }

    function rebuildPopulationAndResample(){
      clampLayouts();
      buildPopulation();
      resample();
    }

    // ====== Events ======
    document.getElementById('designSel').addEventListener('change', ()=>{ syncVisibility(); resample(); });
    document.getElementById('nInput').addEventListener('input', resample);
    document.getElementById('SInput').addEventListener('input', rebuildPopulationAndResample);
    document.getElementById('allocProp').addEventListener('change', resample);
    document.getElementById('allocEqual').addEventListener('change', resample);

    document.getElementById('cRows').addEventListener('input', rebuildPopulationAndResample);
    document.getElementById('cCols').addEventListener('input', rebuildPopulationAndResample);
    document.getElementById('wackyClusters').addEventListener('change', rebuildPopulationAndResample);
    document.getElementById('KInput').addEventListener('input', resample);

    document.getElementById('showGrid').addEventListener('change', draw);
    document.getElementById('clusterBorders').addEventListener('change', draw);
    document.getElementById('highlightClusters').addEventListener('change', draw);

    document.getElementById('btnResample').addEventListener('click', resample);
    document.getElementById('btnShuffle').addEventListener('click', ()=>{ buildPopulation(); resample(); });
    document.getElementById('btnDefaults').addEventListener('click', ()=>{
      document.getElementById('designSel').value = 'srs';
      document.getElementById('nInput').value = 400;
      document.getElementById('SInput').value = 4;
      document.getElementById('allocProp').checked = true;

      document.getElementById('cRows').value = 10;
      document.getElementById('cCols').value = 10;
      document.getElementById('wackyClusters').checked = true;
      document.getElementById('KInput').value = 10;

      document.getElementById('showGrid').checked = true;
      document.getElementById('clusterBorders').checked = true;
      document.getElementById('highlightClusters').checked = true;

      syncVisibility();
      rebuildPopulationAndResample();
    });

    // ====== Init ======
    syncVisibility();
    rebuildPopulationAndResample();
  </script>
</body>
</html>
