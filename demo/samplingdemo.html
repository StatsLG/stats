<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STA220 — Sampling Designs: SRS vs Stratified vs Cluster</title>
  <meta name="description" content="Interactive applet demonstrating SRS, stratified sampling, and cluster sampling." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/style/bctcstyle.css">

  <!-- MathJax for equations -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']],
        processEscapes: true
      },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .viz {
      width: 100%;
      height: 560px;
      border: 1px solid var(--rule);
      border-radius: var(--radius);
      background: #fff;
      display: block;
    }
    .legend { display:flex; flex-wrap:wrap; gap:8px; align-items:center }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--rule); border-radius:999px; background:#fff; font-size:12px }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(0,0,0,.1) }
    .muter { color: var(--muted); font-size:12px }
    .grid2 { display:grid; grid-template-columns: repeat(auto-fit,minmax(240px,1fr)); gap:12px }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .mini { font-size: 12px; color: var(--muted); }
    .scroll-mini { max-height: 260px; overflow:auto; background:#fff; border:1px solid var(--rule); border-radius:8px; }
    .tight-table th, .tight-table td { font-size:12px; padding:4px 6px; }

    /* Layout: single column main content (no left card) */
    .stack { display:grid; gap:12px; }

    /* Population nearly full-screen */
    .pop-card .viz{
      height: min(78vh, 900px);
      width: 100%;
    }

    /* Controls under population */
    .pop-controls{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--rule);
      align-items: end;
    }
    .pop-controls .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pop-controls input[type="number"], .pop-controls select { width: 100%; }

    .pop-toggles{
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--rule);
      align-items:center;
    }
    .pop-toggles .checkline{ margin:0; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ===== LEFT PANEL (BRAND SIDEBAR) ===== -->
    <aside class="sidebar" aria-label="Site navigation">
      <div class="brand">
        <div class="brand-logo" aria-hidden="true"></div>
        <div class="brand-title">BCTC Statistics Hub</div>
      </div>

      <div class="nav-section">
        <h3>Graphing</h3>
        <nav class="nav">
          <a href="/graphing/barchart.html">Bar Chart</a>
          <a href="/graphing/piechart.html">Pie / Donut</a>
          <a href="/graphing/histogram.html">Histogram</a>
          <a href="/graphing/boxplot.html">Box &amp; Whisker</a>
          <a href="/graphing/scatterplot.html">Scatter + Regression</a>
          <a href="/graphing/barchart2way.html">Grouped Bar</a>
        </nav>
      </div>

      <div class="divider" role="separator"></div>

      <div class="nav-section">
        <h3>Analysis</h3>
        <nav class="nav">
          <a href="/descriptive/summary.html">Descriptive Summary</a>
          <a href="/inference/onemean.html">One-Sample Mean Test</a>
        </nav>
      </div>

      <div class="divider" role="separator"></div>

      <div class="nav-section">
        <h3>Notes & Extras</h3>
        <nav class="nav">
          <a href="/STA210U/">STA 210U</a>
          <a href="/STA220/">STA 220</a>
          <a href="/STA296U/">STA 296U</a>
          <a href="/game/pathyfinder.html">Pathy Finder</a>
        </nav>
      </div>

      <div class="footer-note">
        © <span id="yr"></span> StatsLG - Luke Garnett
      </div>
    </aside>

    <!-- ===== RIGHT PANEL (MAIN CONTENT) ===== -->
    <main>
      <header>
        <h1>Sampling Methods: SRS vs Stratified vs Cluster</h1>
        <p>
          The population size is<strong>10,000</strong>, divided equally amoung the four groups.
        </p>
      </header>

      <!-- Single-column layout (no left control panel) -->
      <section class="section wrap" style="grid-template-columns: 1fr;">
        <div class="panel pad">
          <div class="stack">

            <!-- ===== Population + ALL options underneath ===== -->
            <div class="card pop-card">
              <h3 style="margin-top:0;">Population</h3>
              <div class="muter">
                N=<span id="NLabel">—</span>; <span id="dimLabel">—</span>.
                Colors show <span id="legendLabel">Group</span>.
              </div>

              <div class="legend" id="legend" style="margin:8px 0;"></div>
              <svg id="viz" class="viz" viewBox="0 0 760 560" aria-label="Population grid visualization"></svg>

              <!-- Controls (sampling) under the population -->
              <div class="pop-controls" aria-label="Sampling controls">

                <div>
                  <label for="designSel">Sampling Method</label>
                  <select id="designSel">
                    <option value="srs">Simple Random Sample (SRS)</option>
                    <option value="strat">Stratified Random Sample</option>
                    <option value="cluster">Cluster Sample</option>
                  </select>
                </div>

                <div id="nBox">
                  <label for="nInput">Sample size n <span class="muter">(SRS/Stratified)</span></label>
                  <input id="nInput" type="number" min="5" max="5000" value="400" />
                </div>

                <div id="strataBox">
                  <label for="SInput"># of strata (horizontal bands)</label>
                  <input id="SInput" type="number" min="2" max="20" value="4" />
                  <div class="checkline" style="margin-top:6px;">
                    <input type="radio" id="allocProp" name="alloc" value="prop" checked>
                    <label for="allocProp" style="margin:0;">Proportional allocation</label>
                  </div>
                  <div class="checkline">
                    <input type="radio" id="allocEqual" name="alloc" value="equal">
                    <label for="allocEqual" style="margin:0;">Equal \(n_h\)</label>
                  </div>
                </div>

                <div id="clusterBox">
                  <label>Cluster layout (rows × cols)</label>
                  <div class="row">
                    <div style="flex:1; min-width:120px;">
                      <input id="cRows" type="number" min="2" max="50" value="10" />
                      <div class="mini">cluster rows</div>
                    </div>
                    <div style="flex:1; min-width:120px;">
                      <input id="cCols" type="number" min="2" max="50" value="10" />
                      <div class="mini">cluster cols</div>
                    </div>
                  </div>

                  <label style="margin-top:6px;" for="KInput"># clusters to sample (K)</label>
                  <input id="KInput" type="number" min="1" max="2500" value="10" />
                  <p class="muter" style="margin:.4rem 0 0;">Cluster sample size = K × (cluster size).</p>
                </div>

                <div>
                  <label>Actions</label>
                  <div class="row">
                    <button class="btn" id="btnResample">Re-sample</button>
                    <button class="btn outline" id="btnShuffle">Shuffle population</button>
                    <button class="btn ghost" id="btnDefaults">Reset defaults</button>
                  </div>
                </div>
              </div>

              <!-- Display toggles under the controls -->
              <div class="pop-toggles" aria-label="Population display toggles">
                <div class="checkline">
                  <input type="checkbox" id="showGrid" checked>
                  <label for="showGrid" style="margin:0;">Show overlays (match current design)</label>
                </div>

                <div class="checkline">
                  <input type="checkbox" id="clusterBorders" checked>
                  <label for="clusterBorders" style="margin:0;">Show cluster borders (Cluster mode)</label>
                </div>

                <div class="checkline">
                  <input type="checkbox" id="highlightClusters" checked>
                  <label for="highlightClusters" style="margin:0;">Highlight selected clusters</label>
                </div>
              </div>
            </div>

            <!-- ===== Numbers ===== -->
            <div class="card">
              <h3 style="margin-top:0;">Numbers</h3>

              <div class="grid2">
                <div>
                  <p>Population mean \( \mu \): <strong><span id="popMean"></span></strong></p>
                  <p>Population SD \( \sigma \): <span id="popSD"></span></p>
                </div>
                <div>
                  <p>Sample size \( n \): <strong><span id="sampleN"></span></strong></p>
                  <p>Sample mean \( \bar y \): <strong><span id="sampMean"></span></strong></p>
                  <p>Error \( \bar y - \mu \): <strong><span id="err"></span></strong></p>
                </div>
              </div>

              <div style="margin-top:10px;">
                <h4 style="margin:0 0 6px;">
                  Sample composition by stratum <span class="mini">(population groups)</span>
                </h4>
                <div class="scroll-mini">
                  <table class="table tight-table" id="groupTable" aria-label="Sample counts by stratum">
                    <thead>
                      <tr>
                        <th>Stratum</th>
                        <th>Population \(N_h\)</th>
                        <th>Selected</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
                <p class="mini" id="groupTotals" style="margin-top:6px;"></p>
              </div>
            </div>

          </div>
        </div>
      </section>

      <footer class="site-footer">
        Last updated: <span id="lastUpdated"></span>
      </footer>
    </main>
  </div>

  <script>
    // Footer info
    document.getElementById('yr').textContent = new Date().getFullYear();
    document.getElementById('lastUpdated').textContent = new Date(document.lastModified).toLocaleString();

    // ====== Parameters & helpers ======
    const R = 100, C = 100;               // grid size => N = 10,000
    const N = R*C;
    document.getElementById('NLabel').textContent = String(N);
    document.getElementById('dimLabel').textContent = `${R}×${C}`;

    const viz = document.getElementById('viz');
    const fmt = (x,d=3)=> Number.isFinite(x) ? x.toFixed(d) : '—';
    const sum = a => a.reduce((s,v)=>s+v,0);
    const mean = a => sum(a)/a.length;
    const popVar = a => { const m=mean(a); return sum(a.map(v => (v-m)*(v-m)))/a.length; };
    const sd = a => Math.sqrt(popVar(a));
    const randn = (mu=0, sigma=1) => { // Box-Muller
      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return mu + sigma * Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    };
    const choiceK = (arr,k) => {
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a.slice(0,k);
    };

    const palette = [
      '#e7a614', '#3b82f6', '#ef4444', '#10b981', '#a855f7',
      '#fb923c', '#22c55e', '#06b6d4', '#f43f5e', '#8b5cf6'
    ];

    // ====== Build population ======
    let S = 4;                 // strata bands
    let clusterRows = 10, clusterCols = 10;
    let units = [];            // [{id,r,c,y,stratum,clusterId}]
    let sampleSet = new Set(); // selected ids

    function buildPopulation(){
      units = [];

      // stratum boundaries (horizontal) — equal band sizes when possible
      const bandH = Math.floor(R / S);
      const boundaries = Array.from({length:S}, (_,s) => {
        const r0 = s*bandH;
        const r1 = (s===S-1) ? R-1 : (s+1)*bandH - 1;
        return {s, r0, r1};
      });

      // stratum effects for Y
      const effects = Array.from({length:S}, (_,i)=> (i - (S-1)/2) * 8);
      const base = 50, noiseSD = 6;

      // cluster block sizes
      const blockH = R / clusterRows;
      const blockW = C / clusterCols;

      for(let r=0;r<R;r++){
        const b = boundaries.find(b => r>=b.r0 && r<=b.r1);
        const sIdx = b ? b.s : 0;

        for(let c=0;c<C;c++){
          const id = r*C + c;

          const rc = Math.min(Math.floor(r / blockH), clusterRows-1);
          const cc = Math.min(Math.floor(c / blockW), clusterCols-1);
          const clusterId = rc*clusterCols + cc;

          const y = base + effects[sIdx] + randn(0, noiseSD);
          units.push({id, r, c, y, stratum: sIdx, clusterId});
        }
      }
    }

    // ====== Sampling designs ======
    function sampleSRS(n){
      const ids = choiceK(units.map(u=>u.id), Math.min(n,N));
      return new Set(ids);
    }

    function stratAllocations(n, sizes, mode='prop'){
      const S = sizes.length;
      if(mode==='equal'){
        const base = Math.floor(n / S);
        let rem = n - base*S;
        const nh = Array(S).fill(base);
        let i=0; while(rem>0){ nh[i%S]++; i++; rem--; }
        return nh;
      } else {
        const raw = sizes.map(Nh => n * Nh / sum(sizes));
        const flo = raw.map(x => Math.floor(x));
        let rem = n - sum(flo);
        const fracIdx = raw.map((x,i)=>({i, f: x - flo[i]})).sort((a,b)=> b.f - a.f);
        for(let k=0;k<rem;k++) flo[fracIdx[k].i]++;
        return flo;
      }
    }

    function sampleStratified(n, mode='prop'){
      const groups = new Map(); // s -> array of ids
      units.forEach(u => {
        if(!groups.has(u.stratum)) groups.set(u.stratum, []);
        groups.get(u.stratum).push(u.id);
      });
      const sizes = Array.from(groups.values()).map(g=>g.length);
      const nh = stratAllocations(n, sizes, mode);
      const out = new Set();
      Array.from(groups.entries()).forEach(([s, arr], idx) => {
        const k = Math.min(nh[idx], arr.length);
        choiceK(arr, k).forEach(id => out.add(id));
      });
      return out;
    }

    function sampleCluster(K){
      const allClusters = Array.from(new Set(units.map(u => u.clusterId)));
      const chosen = choiceK(allClusters, Math.min(K, allClusters.length));
      const out = new Set(units.filter(u => chosen.includes(u.clusterId)).map(u => u.id));
      return out;
    }

    function chosenClustersFromSample(){
      const set = new Set();
      for(const u of units){
        if(sampleSet.has(u.id)) set.add(u.clusterId);
      }
      return set;
    }

    // ====== Group counts into Numbers card (ALWAYS strata totals) ======
    function updateGroupTable(){
      const tbody = document.querySelector('#groupTable tbody');
      const totalsEl = document.getElementById('groupTotals');

      const popCount = new Map(); // stratum -> Nh
      const selCount = new Map(); // stratum -> selected

      for(const u of units){
        const key = u.stratum; // ALWAYS strata (population groups)
        popCount.set(key, (popCount.get(key)||0) + 1);
        if(sampleSet.has(u.id)){
          selCount.set(key, (selCount.get(key)||0) + 1);
        }
      }

      const keys = Array.from(popCount.keys()).sort((a,b)=>a-b);

      tbody.innerHTML = keys.map(k => `
        <tr>
          <td>Stratum ${k+1}</td>
          <td>${popCount.get(k)}</td>
          <td>${selCount.get(k) || 0}</td>
        </tr>
      `).join('');

      const totalSelected = Array.from(selCount.values()).reduce((s,v)=>s+v,0);
      totalsEl.textContent = `Selected total: ${totalSelected} of ${units.length} units`;
    }

    // ====== Drawing ======
    function draw(){
      const showGrid = document.getElementById('showGrid').checked;
      const design = document.getElementById('designSel').value;
      const legendEl = document.getElementById('legend');
      const legendLabel = document.getElementById('legendLabel');

      viz.innerHTML = '';
      const W=760, H=560, pad=10;
      const cellW = (W - 2*pad) / C;
      const cellH = (H - 2*pad) / R;

      // legend — population stays the same: strata legend always
      legendEl.innerHTML = '';
      legendLabel.textContent = 'strata';
      for(let s=0;s<S;s++){
        const div = document.createElement('div');
        div.className = 'chip';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = palette[s % palette.length];
        div.appendChild(sw);
        div.appendChild(document.createTextNode('Stratum ' + (s+1)));
        legendEl.appendChild(div);
      }

      // cells — ALWAYS colored by STRATUM so population "stays the same"
      for(const u of units){
        const fill = palette[u.stratum % palette.length];

        const x = pad + u.c * cellW;
        const y = pad + u.r * cellH;
        const selected = sampleSet.has(u.id);

        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', Math.max(0.25, cellW));
        rect.setAttribute('height', Math.max(0.25, cellH));
        rect.setAttribute('fill', fill);
        rect.setAttribute('stroke', selected ? '#000' : 'rgba(0,0,0,0.06)');
        rect.setAttribute('stroke-width', selected ? 1.6 : 0.5);
        rect.setAttribute('opacity', selected ? 1 : 0.92);
        viz.appendChild(rect);
      }

      // overlays that MATCH the current design
      if(showGrid){
        if(design === 'cluster'){
          const showBorders = document.getElementById('clusterBorders')?.checked ?? true;
          const highlight = document.getElementById('highlightClusters')?.checked ?? true;

          if(showBorders){
            const blockH = R / clusterRows;
            const blockW = C / clusterCols;
            const chosen = chosenClustersFromSample();

            for(let rc=0; rc<clusterRows; rc++){
              for(let cc=0; cc<clusterCols; cc++){
                const x = pad + cc*blockW*cellW;
                const y = pad + rc*blockH*cellH;
                const w = blockW*cellW;
                const h = blockH*cellH;

                const cid = rc*clusterCols + cc;
                const isChosen = chosen.has(cid);

                const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', w);
                rect.setAttribute('height', h);
                rect.setAttribute('fill', 'none');
                rect.setAttribute('stroke', '#000');
                rect.setAttribute('stroke-width', (isChosen && highlight) ? '2.8' : '1.2');
                rect.setAttribute('opacity', (isChosen && highlight) ? '1' : '0.55');
                viz.appendChild(rect);
              }
            }
          }
        } else if(design === 'strat') {
          // stratified: horizontal band boundaries
          const bandH = Math.floor(R / S);
          for(let s=1; s<S; s++){
            const y = pad + s*bandH*cellH;
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', pad);
            line.setAttribute('x2', W-pad);
            line.setAttribute('y1', y);
            line.setAttribute('y2', y);
            line.setAttribute('stroke', '#000');
            line.setAttribute('stroke-width', '1.5');
            line.setAttribute('stroke-dasharray', '6 6');
            viz.appendChild(line);
          }
        }
      }
    }

    // ====== Orchestration ======
    function resample(){
      const design = document.getElementById('designSel').value;
      const n = +document.getElementById('nInput').value;
      const mode = document.getElementById('allocEqual').checked ? 'equal' : 'prop';
      const K = +document.getElementById('KInput').value;

      if(design==='srs'){
        sampleSet = sampleSRS(n);
      }else if(design==='strat'){
        sampleSet = sampleStratified(n, mode);
      }else{ // cluster
        sampleSet = sampleCluster(K);
      }

      // stats update
      const yPop = units.map(u=>u.y);
      const ySamp = units.filter(u=>sampleSet.has(u.id)).map(u=>u.y);
      document.getElementById('popMean').textContent = fmt(mean(yPop), 3);
      document.getElementById('popSD').textContent = fmt(sd(yPop), 3);
      document.getElementById('sampleN').textContent = String(ySamp.length);
      document.getElementById('sampMean').textContent = fmt(mean(ySamp), 3);
      document.getElementById('err').textContent = fmt(mean(ySamp) - mean(yPop), 3);

      draw();
      updateGroupTable();
    }

    function syncVisibility(){
      const design = document.getElementById('designSel').value;

      document.getElementById('strataBox').style.display = (design==='strat') ? 'block' : 'none';
      document.getElementById('clusterBox').style.display = (design==='cluster') ? 'block' : 'none';
      document.getElementById('nBox').style.display = (design!=='cluster') ? 'block' : 'none';

      // cluster overlay toggles only relevant in cluster mode
      const cb = document.getElementById('clusterBorders');
      const hc = document.getElementById('highlightClusters');
      cb.disabled = (design!=='cluster');
      hc.disabled = (design!=='cluster');
    }

    function nearestDivisor(total, want){
      let best=2, bestDiff=1e9;
      const maxTry = 50;
      for(let k=2;k<=maxTry;k++){
        if(total % k === 0){
          const diff=Math.abs(k-want);
          if(diff<bestDiff){ best=k; bestDiff=diff; }
        }
      }
      return best;
    }

    function clampLayouts(){
      // ensure strata roughly equal-height; clusters tile exactly
      S = Math.max(2, Math.min(20, +document.getElementById('SInput').value||4));
      clusterRows = Math.max(2, Math.min(50, +document.getElementById('cRows').value||10));
      clusterCols = Math.max(2, Math.min(50, +document.getElementById('cCols').value||10));

      if(R % clusterRows !== 0) clusterRows = nearestDivisor(R, clusterRows);
      if(C % clusterCols !== 0) clusterCols = nearestDivisor(C, clusterCols);

      document.getElementById('cRows').value = clusterRows;
      document.getElementById('cCols').value = clusterCols;
      document.getElementById('SInput').value = S;
    }

    function rebuildPopulationAndResample(){
      clampLayouts();
      buildPopulation();
      resample();
    }

    // ====== Events ======
    document.getElementById('designSel').addEventListener('change', ()=>{ syncVisibility(); resample(); });
    document.getElementById('nInput').addEventListener('input', resample);
    document.getElementById('SInput').addEventListener('input', rebuildPopulationAndResample);
    document.getElementById('allocProp').addEventListener('change', resample);
    document.getElementById('allocEqual').addEventListener('change', resample);
    document.getElementById('cRows').addEventListener('input', rebuildPopulationAndResample);
    document.getElementById('cCols').addEventListener('input', rebuildPopulationAndResample);
    document.getElementById('KInput').addEventListener('input', resample);

    document.getElementById('showGrid').addEventListener('change', draw);
    document.getElementById('clusterBorders').addEventListener('change', draw);
    document.getElementById('highlightClusters').addEventListener('change', draw);

    document.getElementById('btnResample').addEventListener('click', resample);
    document.getElementById('btnShuffle').addEventListener('click', ()=>{ buildPopulation(); resample(); });
    document.getElementById('btnDefaults').addEventListener('click', ()=>{
      document.getElementById('designSel').value = 'srs';
      document.getElementById('nInput').value = 400;
      document.getElementById('SInput').value = 4;
      document.getElementById('allocProp').checked = true;

      document.getElementById('cRows').value = 10;
      document.getElementById('cCols').value = 10;
      document.getElementById('KInput').value = 10;

      document.getElementById('showGrid').checked = true;
      document.getElementById('clusterBorders').checked = true;
      document.getElementById('highlightClusters').checked = true;

      syncVisibility();
      rebuildPopulationAndResample();
    });

    // ====== Init ======
    syncVisibility();
    buildPopulation();
    resample();
  </script>
</body>
</html>
