<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CI Coverage Demo (Columns) — StatsLG</title>
  <meta name="description" content="Confidence interval coverage demo with horizontal parameter line and per-sample columns." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/style/bctcstyle.css">

  <!-- (optional) MathJax for pretty math in labels) -->
  <script>
    window.MathJax = { tex:{ inlineMath:[['\\(','\\)'],['$','$']] } };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .viz-card{ padding:14px; }
    .controls{ display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap:12px; }
    .viz-wrap{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px; }
    .hscroll{ overflow-x:auto; overflow-y:hidden; border:1px solid var(--rule); border-radius:12px; background:#fff; }
    .viz{ display:block; height:320px; }
    .viz-short{ height:360px }
    .muted-small{ color:var(--muted); font-size:12px }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ===== Shared sidebar include (robust paths for GitHub Pages) ===== -->
    <aside class="sidebar" aria-label="Site navigation" data-include="partials/sidebar.html"></aside>

    <main>
      <header>
        <h1>Confidence Interval Coverage (Mean, z-interval)</h1>
        <p class="subtitle">
          Now with a <strong>horizontal</strong> parameter line \( \mu \) and <strong>one column per sample</strong>.<br>
          Panel A: dots are \(\bar x\) vs a horizontal band \( \mu \pm z^*\sigma/\sqrt{n} \).<br>
          Panel B: vertical CIs \( \bar x \pm z^*\sigma/\sqrt{n} \) with a single short dash at \(\bar x\).
        </p>
      </header>

      <section class="section">
        <div class="card viz-card">
          <div class="controls">
            <div class="card soft">
              <label>True mean \( \mu \)</label>
              <input id="mu" type="number" step="0.01" value="100">
              <label style="margin-top:8px;">Population SD \( \sigma \)</label>
              <input id="sigma" type="number" min="0.0001" step="0.0001" value="15">
            </div>
            <div class="card soft">
              <label>Sample size \( n \)</label>
              <input id="n" type="number" min="2" step="1" value="25">
              <label style="margin-top:8px;">Confidence level (%)</label>
              <input id="conf" type="number" min="50" max="99.9" step="0.1" value="95">
            </div>
            <div class="card soft">
              <label>Number of samples</label>
              <input id="nsamp" type="number" min="5" max="400" step="1" value="60">
              <div class="row" style="gap:8px; margin-top:8px;">
                <button class="btn" id="resample">Resample</button>
                <button class="btn ghost" id="step">Add 1</button>
              </div>
              <p class="muted-small" style="margin:.4rem 0 0;">
                Samples generated as \( \bar X \sim \mathcal N(\mu,\; \sigma/\sqrt{n}) \) for speed.
              </p>
            </div>
            <div class="card soft">
              <div class="muted-small">Current settings</div>
              <div id="kSE" style="font-weight:800;">SE = —</div>
              <div id="kZstar" style="font-weight:800;">z* = —</div>
              <div id="kMargin" style="font-weight:800;">Margin = —</div>
              <div id="kCover" style="font-weight:800; margin-top:6px;">Coverage = —</div>
            </div>
          </div>

          <div class="viz-wrap">
            <div class="hscroll"><svg id="panelA" class="viz" role="img" aria-label="Sample means vs horizontal acceptance band"></svg></div>
            <div class="hscroll"><svg id="panelB" class="viz viz-short" role="img" aria-label="Per-sample vertical confidence intervals"></svg></div>
          </div>
        </div>
      </section>

      <footer>
        Last updated: <span id="lastUpdated"></span>
      </footer>
    </main>
  </div>

  <script>
    // ---------- Sidebar include (robust for user/project GitHub Pages) ----------
    (async function injectSidebar(){
      const el = document.querySelector('[data-include]'); if(!el) return;
      const given = el.getAttribute('data-include') || 'partials/sidebar.html';
      const firstSeg = location.pathname.split('/').filter(Boolean)[0] || '';
      const base = firstSeg ? ('/' + firstSeg) : '';
      const candidates = [
        given, '/' + given.replace(/^\//,''), base + '/' + given.replace(/^\//,''),
        base + '/partials/sidebar.html', '/partials/sidebar.html'
      ].filter((v,i,a)=>a.indexOf(v)===i);
      let html = '';
      for (const url of candidates){
        try{ const r = await fetch(url, {cache:'no-cache'}); if (r.ok){ html = await r.text(); break; } }catch(_){}
      }
      el.innerHTML = html || '<div class="muted">Sidebar failed to load.</div>';
      const yr = el.querySelector('#yr'); if (yr) yr.textContent = new Date().getFullYear();
    })();
    document.getElementById('lastUpdated').textContent = new Date(document.lastModified).toLocaleString();

    // ---------- Normal CDF + robust inverse ----------
    const SQRT2 = Math.SQRT2;
    function cdf(z){
      const sign = z < 0 ? -1 : 1;
      z = Math.abs(z)/SQRT2;
      const t = 1/(1+0.3275911*z);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
      const erf = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
      return 0.5*(1 + sign*erf);
    }
    function invnorm(p){
      if (p<=0) return -10; if (p>=1) return 10;
      let lo=-10, hi=10;
      for (let i=0;i<80;i++){ const mid=(lo+hi)/2, cm=cdf(mid); if (cm<p) lo=mid; else hi=mid; }
      return (lo+hi)/2;
    }

    // ---------- RNG ----------
    function rnorm(mean=0, sd=1){
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      const z=Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
      return mean + sd*z;
    }

    // ---------- Elements & state ----------
    const muEl = document.getElementById('mu');
    const sigmaEl = document.getElementById('sigma');
    const nEl = document.getElementById('n');
    const confEl = document.getElementById('conf');
    const nsampEl = document.getElementById('nsamp');
    const resampleBtn = document.getElementById('resample');
    const stepBtn = document.getElementById('step');

    const kSE = document.getElementById('kSE');
    const kZstar = document.getElementById('kZstar');
    const kMargin = document.getElementById('kMargin');
    const kCover = document.getElementById('kCover');

    const svgA = document.getElementById('panelA');
    const svgB = document.getElementById('panelB');

    let sampleMeans = [];
    let yScale = {lo:0, hi:1};  // value scale (shared across panels)

    function computeCore(){
      const mu = +muEl.value || 0;
      const sigma = Math.max(1e-9, +sigmaEl.value || 1);
      const n = Math.max(2, +nEl.value || 2);
      const conf = Math.max(50, Math.min(99.9, +confEl.value || 95));
      const alpha2 = (1 - conf/100)/2;
      const zstar = invnorm(1 - alpha2);
      const SE = sigma / Math.sqrt(n);
      const m = Math.max(1e-12, zstar*SE);
      return { mu, sigma, n, conf, zstar, SE, m };
    }

    function fmt(x,d=4){
      if (!isFinite(x)) return '—';
      const ax = Math.abs(x);
      if (ax>0 && (ax<1e-3 || ax>=1e6)) return x.toExponential(2);
      return x.toFixed(d);
    }

    function updateKPIs(core, coverageCount){
      kSE.textContent     = `SE = ${fmt(core.SE, 6)}`;
      kZstar.textContent  = `z* = ${fmt(core.zstar, 4)}`;
      kMargin.textContent = `Margin = ${fmt(core.m, 6)}`;
      const nS = sampleMeans.length;
      const txt = nS ? `${coverageCount}/${nS} cover (≈ ${(100*coverageCount/nS).toFixed(1)}%)` : '—';
      kCover.innerHTML = `Coverage = ${txt}`;
    }

    function clearSVG(svg){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

    // ---- Layout helpers: make the SVG wide enough for one column per sample
    function layoutFor(svg, n, baseHeight=320){
      const m = {t:16, r:16, b:32, l:48};
      const colW = 22;                  // px per sample column (tweak if you want denser)
      const W = m.l + m.r + Math.max(1,n)*colW;
      const H = baseHeight;
      svg.setAttribute('width', W);
      svg.setAttribute('height', H);
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      return {m, W, H, colW, plotW: W - m.l - m.r, plotH: H - m.t - m.b};
    }

    function computeYScale(core){
      if (!sampleMeans.length){
        const span = Math.max(4*core.SE, 1.5*core.m, 1);
        return {lo: core.mu - span, hi: core.mu + span};
      }
      let lo = Infinity, hi = -Infinity;
      for (const xbar of sampleMeans){
        lo = Math.min(lo, xbar - core.m);
        hi = Math.max(hi, xbar + core.m);
      }
      if (!isFinite(lo) || !isFinite(hi) || lo===hi){
        const span = Math.max(4*core.SE, 1.5*core.m, 1);
        return {lo: core.mu - span, hi: core.mu + span};
      }
      const pad = 0.15*(hi - lo || 1);
      return {lo: lo - pad, hi: hi + pad};
    }

    // map value -> y pixel (higher value -> higher up)
    function yMap(v, L){ return L.m.t + (L.plotH)*(1 - (v - yScale.lo)/(yScale.hi - yScale.lo)); }

    // ---------- Panel A: dots in columns, horizontal μ & band ----------
    function drawPanelA(core){
      clearSVG(svgA);
      const n = sampleMeans.length || (+nsampEl.value || 60);
      const L = layoutFor(svgA, n, 320);

      yScale = computeYScale(core);
      const xColCenter = i => L.m.l + (i + 0.5)*L.colW;

      // y-axis ticks
      const ticks = 6;
      for (let i=0;i<=ticks;i++){
        const v = yScale.lo + i*(yScale.hi - yScale.lo)/ticks;
        const y = yMap(v, L);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', L.m.l-6); line.setAttribute('x2', L.m.l);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#111827'); svgA.appendChild(line);
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.setAttribute('x', L.m.l-8); lab.setAttribute('y', y+4);
        lab.setAttribute('text-anchor','end'); lab.setAttribute('font-size','11'); lab.setAttribute('fill','#4b5563');
        lab.textContent = fmt(v,2); svgA.appendChild(lab);
      }

      // μ horizontal line
      const yMu = yMap(core.mu, L);
      const muLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      muLine.setAttribute('x1', L.m.l); muLine.setAttribute('x2', L.m.l+L.plotW);
      muLine.setAttribute('y1', yMu); muLine.setAttribute('y2', yMu);
      muLine.setAttribute('stroke', '#111827'); muLine.setAttribute('stroke-width', '2');
      svgA.appendChild(muLine);

      const muLab = document.createElementNS('http://www.w3.org/2000/svg','text');
      muLab.setAttribute('x', L.m.l+6); muLab.setAttribute('y', yMu-6);
      muLab.setAttribute('font-size','12'); muLab.setAttribute('fill', '#111827');
      muLab.textContent = 'μ (true)'; svgA.appendChild(muLab);

      // acceptance band: μ ± m (horizontal band across full width)
      const y1 = yMap(core.mu + core.m, L), y2 = yMap(core.mu - core.m, L);
      const band = document.createElementNS('http://www.w3.org/2000/svg','rect');
      band.setAttribute('x', L.m.l);
      band.setAttribute('y', Math.min(y1,y2));
      band.setAttribute('width', L.plotW);
      band.setAttribute('height', Math.abs(y2 - y1));
      band.setAttribute('fill', 'rgba(16,185,129,0.18)');
      band.setAttribute('stroke', '#10b981'); band.setAttribute('stroke-width', '1');
      // draw band first → send to back
      svgA.insertBefore(band, svgA.firstChild);

      // dots per column
      let coverCount = 0;
      for (let i=0;i<sampleMeans.length;i++){
        const xbar = sampleMeans[i];
        const covers = Math.abs(xbar - core.mu) <= core.m;
        if (covers) coverCount++;
        const cx = xColCenter(i);
        const cy = yMap(xbar, L);
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy);
        dot.setAttribute('r', 4);
        dot.setAttribute('fill', covers ? '#10b981' : '#ef4444');
        dot.setAttribute('stroke', covers ? '#065f46' : '#7f1d1d');
        svgA.appendChild(dot);
      }

      // x-axis: sample index (sparse labels)
      const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
      axis.setAttribute('x1', L.m.l); axis.setAttribute('x2', L.m.l+L.plotW);
      axis.setAttribute('y1', L.m.t+L.plotH+4); axis.setAttribute('y2', L.m.t+L.plotH+4);
      axis.setAttribute('stroke','#111827'); svgA.appendChild(axis);

      const step = Math.max(1, Math.round(n/12));
      for (let i=0;i<n;i+=step){
        const x = xColCenter(i);
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x', x); t.setAttribute('y', L.m.t+L.plotH+18);
        t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','11'); t.setAttribute('fill','#4b5563');
        t.textContent = i+1; svgA.appendChild(t);
      }

      const legend = document.createElementNS('http://www.w3.org/2000/svg','text');
      legend.setAttribute('x', L.m.l); legend.setAttribute('y', L.m.t - 2);
      legend.setAttribute('font-size','12'); legend.setAttribute('fill','#4b5563');
      legend.textContent = 'Panel A • Dots = sample means; inside green band → CI would cover μ';
      svgA.appendChild(legend);

      updateKPIs(core, coverCount);
    }

    // ---------- Panel B: vertical intervals per column; single short dash at mean ----------
    function drawPanelB(core){
      clearSVG(svgB);
      const n = sampleMeans.length || (+nsampEl.value || 60);
      const L = layoutFor(svgB, n, 360);
      const xColCenter = i => L.m.l + (i + 0.5)*L.colW;

      // reuse yScale computed in Panel A

      // y-axis ticks
      const ticks = 6;
      for (let i=0;i<=ticks;i++){
        const v = yScale.lo + i*(yScale.hi - yScale.lo)/ticks;
        const y = yMap(v, L);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', L.m.l-6); line.setAttribute('x2', L.m.l);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#111827'); svgB.appendChild(line);
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.setAttribute('x', L.m.l-8); lab.setAttribute('y', y+4);
        lab.setAttribute('text-anchor','end'); lab.setAttribute('font-size','11'); lab.setAttribute('fill','#4b5563');
        lab.textContent = fmt(v,2); svgB.appendChild(lab);
      }

      // μ horizontal line
      const yMu = yMap(core.mu, L);
      const muLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      muLine.setAttribute('x1', L.m.l); muLine.setAttribute('x2', L.m.l+L.plotW);
      muLine.setAttribute('y1', yMu); muLine.setAttribute('y2', yMu);
      muLine.setAttribute('stroke', '#111827'); muLine.setAttribute('stroke-width', '2');
      svgB.appendChild(muLine);

      const muLab = document.createElementNS('http://www.w3.org/2000/svg','text');
      muLab.setAttribute('x', L.m.l+6); muLab.setAttribute('y', yMu-6);
      muLab.setAttribute('font-size','12'); muLab.setAttribute('fill', '#111827');
      muLab.textContent = 'μ (true)'; svgB.appendChild(muLab);

      // intervals per sample
      const dashW = 10; // horizontal dash length at the mean
      for (let i=0;i<sampleMeans.length;i++){
        const xbar = sampleMeans[i];
        const covers = Math.abs(xbar - core.mu) <= core.m;
        const cx = xColCenter(i);
        const yLo = yMap(xbar - core.m, L);
        const yHi = yMap(xbar + core.m, L);

        // vertical interval line
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', cx); line.setAttribute('x2', cx);
        line.setAttribute('y1', Math.min(yLo,yHi)); line.setAttribute('y2', Math.max(yLo,yHi));
        line.setAttribute('stroke', covers ? '#10b981' : '#ef4444');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-linecap', 'round');
        svgB.appendChild(line);

        // single short horizontal dash at the sample mean
        const yMean = yMap(xbar, L);
        const dash = document.createElementNS('http://www.w3.org/2000/svg','line');
        dash.setAttribute('x1', cx - dashW/2); dash.setAttribute('x2', cx + dashW/2);
        dash.setAttribute('y1', yMean); dash.setAttribute('y2', yMean);
        dash.setAttribute('stroke', '#00467f');
        dash.setAttribute('stroke-width', '3');
        dash.setAttribute('stroke-linecap', 'round');
        svgB.appendChild(dash);
      }

      // x-axis: sample index (sparse labels)
      const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
      axis.setAttribute('x1', L.m.l); axis.setAttribute('x2', L.m.l+L.plotW);
      axis.setAttribute('y1', L.m.t+L.plotH+4); axis.setAttribute('y2', L.m.t+L.plotH+4);
      axis.setAttribute('stroke','#111827'); svgB.appendChild(axis);

      const step = Math.max(1, Math.round(sampleMeans.length/12));
      for (let i=0;i<sampleMeans.length;i+=step){
        const x = xColCenter(i);
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x', x); t.setAttribute('y', L.m.t+L.plotH+18);
        t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','11'); t.setAttribute('fill','#4b5563');
        t.textContent = i+1; svgB.appendChild(t);
      }

      const legend = document.createElementNS('http://www.w3.org/2000/svg','text');
      legend.setAttribute('x', L.m.l); legend.setAttribute('y', L.m.t - 2);
      legend.setAttribute('font-size','12'); legend.setAttribute('fill','#4b5563');
      legend.textContent = 'Panel B • One vertical CI per sample; short blue dash marks the mean';
      svgB.appendChild(legend);

      const covered = sampleMeans.reduce((acc,xbar)=>acc + ((Math.abs(xbar - core.mu)<=core.m)?1:0), 0);
      updateKPIs(core, covered);
    }

    function redraw(){
      const core = computeCore();
      drawPanelA(core);
      drawPanelB(core);
    }

    function resampleAll(){
      const core = computeCore();
      const R = Math.max(5, Math.min(400, +nsampEl.value || 60));
      const se = core.SE;
      sampleMeans = Array.from({length:R}, ()=> rnorm(core.mu, se));
      redraw();
    }
    function addOne(){
      const core = computeCore();
      sampleMeans.push(rnorm(core.mu, core.SE));
      redraw();
    }

    // Wiring
    [muEl, sigmaEl, nEl, confEl, nsampEl].forEach(el=>{
      el.addEventListener('change', resampleAll);
      el.addEventListener('input', resampleAll);
    });
    resampleBtn.addEventListener('click', resampleAll);
    stepBtn.addEventListener('click', addOne);

    // Redraw on resize so vertical scale never collapses
    const ro = new ResizeObserver(()=>redraw());
    ro.observe(document.body);

    // initial
    setTimeout(resampleAll, 0);
  </script>
</body>
</html>


