<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tower Defense ‚Äî StatsLG</title>
  <meta name="description" content="A browser-based tower defense starter demo skinned with BCTC styles." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/style/bctcstyle.css">
  <style>
    /* Light, brand-aware polish that leans on your CSS variables */
    :root{
      --td-bg: var(--bg, #ffffff);
      --td-ink: var(--ink, #0f172a);
      --td-panel: var(--panel, #f5f7fb);
      --td-rule: var(--rule, #e5e7eb);
      --td-blue: var(--kctcs-blue, #00467f);
      --td-gold: var(--kctcs-gold, #e7a614);
    }
    .td-header { display:flex; gap:1rem; align-items:center; justify-content:space-between; }
    .td-badge { background:var(--td-blue); color:#fff; padding:.25rem .5rem; border-radius:.5rem; font-weight:700; }
    .td-hud { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .td-pill { background:var(--td-panel); border:1px solid var(--td-rule); border-radius:999px; padding:.35rem .7rem; }
    .td-pill b{ font-weight:700; }
    .td-toolbar { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; }
    .td-toolbar button{
      cursor:pointer; border-radius:10px; padding:.5rem .8rem; font-weight:700;
      border:1px solid var(--td-rule); background:#fff;
    }
    .td-toolbar button.primary{ background:var(--td-blue); color:#fff; border-color:var(--td-blue); }
    .td-toolbar button.danger{ background:#b91c1c; color:#fff; border-color:#7f1d1d; }
    .td-toolbar button.good{ background:#16a34a; color:#fff; border-color:#14532d; }
    .td-canvas-wrap{ position:relative }
    canvas{ display:block; width:100%; height:auto; background:#0a0f1a; border-radius:14px; border:1px solid var(--td-rule) }
    .tip { color:var(--muted,#4b5563); font-size:.95rem; margin-top:.5rem }
    .legend span{ display:inline-block; width:14px; height:14px; border-radius:3px; margin-right:6px; vertical-align:-2px }
    @media (max-width: 900px){
      .td-header { flex-direction:column; align-items:flex-start; gap:.75rem; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ===== SIDEBAR (shared include) ===== -->
    <aside class="sidebar" aria-label="Site navigation" data-include="/partials/sidebar.html"></aside>

    <!-- ===== MAIN CONTENT ===== -->
    <main>
      <header class="td-header">
        <h1 style="margin:0">
          <span class="td-badge">TD</span>
          Tower Defense ‚Äî Starter
        </h1>
        <div class="td-hud">
          <div class="td-pill">üí∞ Coins: <b id="coins">100</b></div>
          <div class="td-pill">‚ù§Ô∏è Lives: <b id="lives">20</b></div>
          <div class="td-pill">üåä Wave: <b id="wave">0</b></div>
          <div class="td-pill">‚è±Ô∏è Speed: <b id="speed">1√ó</b></div>
          <div class="td-pill">üó°Ô∏è Tower cost: <b id="cost">25</b></div>
        </div>
      </header>

      <section class="panel" style="margin-top:1rem">
        <div class="td-canvas-wrap">
          <canvas id="game" width="720" height="480" aria-label="Tower Defense Game Canvas"></canvas>
        </div>
        <div class="td-toolbar">
          <button id="btnStart" class="primary">Start Wave</button>
          <button id="btnPause">Pause</button>
          <button id="btnSpeed">Speed 2√ó</button>
          <button id="btnSell" class="danger">Sell Mode</button>
          <button id="btnRange" class="good">Toggle Range</button>
        </div>
        <p class="tip">Click a grass tile to place a tower (if you can afford it). Avoid the path. Use Sell Mode to remove towers (refund 70%).</p>
      </section>

      <section class="panel" style="margin-top:1rem">
        <h2 style="margin:.25rem 0 .5rem">Legend</h2>
        <p class="legend">
          <span style="background:#3b82f6"></span> Path ‚Ä¢
          <span style="background:#10b981"></span> Grass ‚Ä¢
          <span style="background:#f97316"></span> Enemy ‚Ä¢
          <span style="background:#a855f7"></span> Tower ‚Ä¢
          <span style="background:#eab308"></span> Bullet
        </p>
        <h3 style="margin:.75rem 0 .5rem">Roadmap</h3>
        <ul style="margin:.25rem 0 .25rem 1rem">
          <li>New tower types (slow, splash, poison)</li>
          <li>Different enemy species (fast, armored, boss)</li>
          <li>Multiple maps & randomized paths</li>
          <li>Upgrade tree & hotkeys</li>
          <li>Mobile controls + SFX</li>
        </ul>
      </section>
    </main>
  </div>

  <!-- ===== Simple include loader (if your base layout doesn't already do this) ===== -->
  <script>
    (function loadIncludes(){
      const incs = Array.from(document.querySelectorAll('[data-include]'));
      incs.forEach(async el=>{
        try{
          const url = el.getAttribute('data-include');
          const res = await fetch(url, {cache:'no-store'});
          if(res.ok) el.innerHTML = await res.text();
        }catch(_){}
      });
    })();
  </script>

  <!-- ===== Game Code ===== -->
  <script>
  // ==== Constants / Config ====
  const TILE = 30;                    // 24 x 16 grid on 720x480
  const W = 24, H = 16;
  const START_COINS = 100, START_LIVES = 20;
  const TOWER_COST = 25, SELL_REFUND = 0.7;
  const ENEMY_BASE_HP = 25, ENEMY_BASE_SPEED = 40, ENEMY_REWARD = 6;
  const FIRE_RATE = 0.8, BULLET_SPEED = 260, DAMAGE = 12, RANGE = 120;

  // ==== Canvas / State ====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const ui = {
    coins: coins, lives: lives, wave: wave, speed: speed, cost: cost,
    btnStart: btnStart, btnPause: btnPause, btnSpeed: btnSpeed, btnSell: btnSell, btnRange: btnRange
  };
  ui.cost.textContent = TOWER_COST;

  let gameSpeed = 1, showRange = true, sellMode = false, paused = false;

  const game = {
    coins: START_COINS, lives: START_LIVES, wave: 0,
    time: 0, spawnTimer: 0, enemiesToSpawn: 0,
    enemies: [], towers: [], bullets: []
  };

  function uih(){
    ui.coins.textContent = game.coins|0;
    ui.lives.textContent = game.lives|0;
    ui.wave.textContent  = game.wave|0;
    ui.speed.textContent = gameSpeed + '√ó';
  }

  // ==== Map & Path ====
  const waypoints = [[0,7],[5,7],[5,3],[12,3],[12,11],[19,11],[19,6],[23,6]]
    .map(([gx,gy]) => ({x: gx*TILE + TILE/2, y: gy*TILE + TILE/2}));

  const pathMask = new Set();
  (function rasterizePath(){
    function addTileAt(x,y){ pathMask.add(Math.floor(x/TILE)+','+Math.floor(y/TILE)); }
    for (let i=0;i<waypoints.length-1;i++){
      const a=waypoints[i], b=waypoints[i+1], dx=b.x-a.x, dy=b.y-a.y, len=Math.hypot(dx,dy);
      const steps = Math.max(1, Math.ceil(len / (TILE/2)));
      for (let s=0;s<=steps;s++){ const t=s/steps; addTileAt(a.x+dx*t, a.y+dy*t); }
    }
  })();

  // ==== Entities ====
  class Enemy{
    constructor(hp,speed){ this.x=waypoints[0].x; this.y=waypoints[0].y; this.hp=hp; this.maxHp=hp; this.speed=speed; this.i=0; this.alive=true; this.radius=10; }
    update(dt){
      const target = waypoints[this.i+1];
      if(!target){ this.alive=false; game.lives-=1; uih(); return; }
      const dx=target.x-this.x, dy=target.y-this.y, dist=Math.hypot(dx,dy), step=this.speed*dt*gameSpeed;
      if(step>=dist){ this.x=target.x; this.y=target.y; this.i++; } else { this.x+=dx/dist*step; this.y+=dy/dist*step; }
    }
    draw(g){
      g.fillStyle='#f97316'; g.beginPath(); g.arc(this.x,this.y,this.radius,0,Math.PI*2); g.fill();
      const w=22,h=4, px=this.x-w/2, py=this.y-this.radius-8;
      g.fillStyle='#00000088'; g.fillRect(px,py,w,h);
      g.fillStyle='#16a34a'; g.fillRect(px,py,w*(this.hp/this.maxHp),h);
      g.strokeStyle='#000000bb'; g.strokeRect(px,py,w,h);
    }
  }

  class Tower{
    constructor(gx,gy){ this.gx=gx; this.gy=gy; this.x=gx*TILE+TILE/2; this.y=gy*TILE+TILE/2; this.range=RANGE; this.cooldown=0; this.rof=FIRE_RATE; }
    update(dt){
      this.cooldown -= dt*gameSpeed;
      if(this.cooldown<=0){
        const target=this.acquire();
        if(target){ fireBullet(this.x,this.y,target); this.cooldown=1/this.rof; }
      }
    }
    acquire(){
      let best=null, bestI=-1;
      for(const e of game.enemies){
        if(!e.alive) continue;
        const d=Math.hypot(e.x-this.x,e.y-this.y);
        if(d<=this.range && e.i>bestI){ best=e; bestI=e.i; }
      }
      return best;
    }
    draw(g){
      g.fillStyle='#a855f7'; g.beginPath(); g.arc(this.x,this.y,12,0,Math.PI*2); g.fill();
      g.fillStyle='#2e1065'; g.beginPath(); g.arc(this.x,this.y,6,0,Math.PI*2); g.fill();
      if(showRange){ g.strokeStyle='#a855f744'; g.beginPath(); g.arc(this.x,this.y,this.range,0,Math.PI*2); g.stroke(); }
    }
  }

  class Bullet{
    constructor(x,y,target){ this.x=x; this.y=y; this.r=4; this.target=target; this.speed=BULLET_SPEED; this.alive=true; }
    update(dt){
      if(!this.target || !this.target.alive){ this.alive=false; return; }
      const dx=this.target.x-this.x, dy=this.target.y-this.y, dist=Math.hypot(dx,dy), step=this.speed*dt*gameSpeed;
      if(step>=dist){ this.target.hp-=DAMAGE; if(this.target.hp<=0){ this.target.alive=false; game.coins+=ENEMY_REWARD; uih(); } this.alive=false; }
      else { this.x+=dx/dist*step; this.y+=dy/dist*step; }
    }
    draw(g){ g.fillStyle='#eab308'; g.beginPath(); g.arc(this.x,this.y,this.r,0,Math.PI*2); g.fill(); }
  }

  // ==== Waves / Spawning ====
  function startWave(){
    if(game.enemiesToSpawn>0) return;
    game.wave+=1; uih();
    game.enemiesToSpawn = 7 + Math.floor(game.wave*1.5);
    game.spawnTimer = 0;
  }
  function spawnEnemy(){
    const hp = ENEMY_BASE_HP + Math.floor((game.wave-1)*6);
    const speed = ENEMY_BASE_SPEED + Math.min(50,(game.wave-1)*3);
    game.enemies.push(new Enemy(hp,speed));
  }

  // ==== Helpers ====
  function fireBullet(x,y,target){ game.bullets.push(new Bullet(x,y,target)); }
  function inBoundsGX(gx,gy){ return gx>=0 && gy>=0 && gx<W && gy<H; }
  function tileKey(gx,gy){ return gx+','+gy; }
  function tileAt(x,y){ return [Math.floor(x/TILE), Math.floor(y/TILE)]; }
  function canPlace(gx,gy){
    if(!inBoundsGX(gx,gy)) return false;
    if(pathMask.has(tileKey(gx,gy))) return false;
    for(const t of game.towers){ if(t.gx===gx && t.gy===gy) return false; }
    return true;
  }

  // ==== Input ====
  const mouse = {x:-9999,y:-9999};
  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width/r.width);
    mouse.y = (e.clientY - r.top ) * (canvas.height/r.height);
  });
  canvas.addEventListener('mouseleave', ()=>{ mouse.x=mouse.y=-9999; });
  canvas.addEventListener('click', ()=>{
    const [gx,gy]=tileAt(mouse.x,mouse.y);
    if(!inBoundsGX(gx,gy)) return;

    if(sellMode){
      for(let i=0;i<game.towers.length;i++){
        const t=game.towers[i];
        if(t.gx===gx && t.gy===gy){
          game.towers.splice(i,1);
          game.coins += Math.round(TOWER_COST*SELL_REFUND);
          uih(); return;
        }
      }
      return;
    }

    if(canPlace(gx,gy) && game.coins>=TOWER_COST){
      game.towers.push(new Tower(gx,gy));
      game.coins -= TOWER_COST; uih();
    }
  });

  ui.btnStart.onclick = startWave;
  ui.btnPause.onclick = ()=>{ paused=!paused; ui.btnPause.textContent = paused ? 'Resume' : 'Pause'; };
  ui.btnSpeed.onclick = ()=>{ gameSpeed = (gameSpeed===1)?2:1; ui.btnSpeed.textContent = (gameSpeed===1)?'Speed 2√ó':'Speed 1√ó'; uih(); };
  ui.btnSell.onclick  = ()=>{ sellMode=!sellMode; ui.btnSell.textContent = sellMode ? 'Sell Mode (ON)' : 'Sell Mode'; };
  ui.btnRange.onclick = ()=>{ showRange=!showRange; ui.btnRange.textContent = showRange ? 'Hide Range' : 'Show Range'; };

  // ==== Loop ====
  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.05,(t-last)/1000); last=t;
    if(!paused){ update(dt); draw(); } else { draw(); }
    requestAnimationFrame(loop);
  }

  function update(dt){
    game.time += dt*gameSpeed;

    if(game.enemiesToSpawn>0){
      game.spawnTimer -= dt*gameSpeed;
      if(game.spawnTimer<=0){ spawnEnemy(); game.enemiesToSpawn--; game.spawnTimer=0.6; }
    }

    for(const e of game.enemies) if(e.alive) e.update(dt);
    for(const t of game.towers) t.update(dt);
    for(const b of game.bullets) if(b.alive) b.update(dt);

    game.enemies = game.enemies.filter(e=>e.alive);
    game.bullets = game.bullets.filter(b=>b.alive);

    if(game.lives<=0){
      paused=true;
      ui.btnPause.textContent='Restart';
      ui.btnPause.onclick=()=>location.reload();
    }
  }

  function drawGrid(g){
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const px=x*TILE, py=y*TILE;
        const k=x+','+y;
        g.fillStyle = pathMask.has(k) ? '#1d3a75' : '#0e1a2a';
        g.fillRect(px,py,TILE,TILE);
        g.strokeStyle = '#0b1220'; g.strokeRect(px,py,TILE,TILE);
      }
    }
    // Path guideline
    g.strokeStyle = '#3b82f6'; g.lineWidth=6; g.lineJoin='round';
    g.beginPath(); g.moveTo(waypoints[0].x,waypoints[0].y);
    for(let i=1;i<waypoints.length;i++) g.lineTo(waypoints[i].x,waypoints[i].y);
    g.stroke(); g.lineWidth=1;
  }

  function drawGhost(g){
    const [gx,gy]=tileAt(mouse.x,mouse.y);
    if(!inBoundsGX(gx,gy)) return;
    const px=gx*TILE, py=gy*TILE;

    if(sellMode){
      let here=false; for(const t of game.towers){ if(t.gx===gx && t.gy===gy){ here=true; break; } }
      g.fillStyle = here ? '#ef444455' : '#ef444422';
      g.fillRect(px,py,TILE,TILE);
      g.strokeStyle='#ef4444aa'; g.strokeRect(px,py,TILE,TILE);
      return;
    }

    const ok = canPlace(gx,gy) && game.coins>=TOWER_COST;
    g.fillStyle = ok ? '#22c55e33' : '#ef444433';
    g.fillRect(px,py,TILE,TILE);
    g.strokeStyle = ok ? '#22c55eaa' : '#ef4444aa';
    g.strokeRect(px,py,TILE,TILE);

    const cx=px+TILE/2, cy=py+TILE/2;
    g.strokeStyle='#a855f744'; g.beginPath(); g.arc(cx,cy,RANGE,0,Math.PI*2); g.stroke();
    g.fillStyle='#a855f777'; g.beginPath(); g.arc(cx,cy,12,0,Math.PI*2); g.fill();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid(ctx);
    for(const t of game.towers) t.draw(ctx);
    for(const b of game.bullets) b.draw(ctx);
    for(const e of game.enemies) e.draw(ctx);
    drawGhost(ctx);

    if(paused && game.lives>0){
      ctx.fillStyle='#00000066'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font='700 28px system-ui'; ctx.textAlign='center';
      ctx.fillText('Paused', canvas.width/2, canvas.height/2);
    }
  }

  uih(); requestAnimationFrame(loop);
  </script>
</body>
</html>
