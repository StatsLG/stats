<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pathy Finder (Top-Down + Degree Collectible)</title>
  <style>
    :root{ --fg:#e8f0fe; --muted:#9fb3c8; --accent:#52d67a; }
    html,body{height:100%}
    body{
      margin:0; background:#0b1320; color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
      display:grid; place-items:center
    }
    .wrap{display:flex; flex-direction:column; gap:.75rem; align-items:center}
    canvas{
      background:#254228; /* fully painted each frame; safety color */
      border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      touch-action:none
    }
    .hud{display:flex; gap:.75rem; align-items:center; justify-content:center; flex-wrap:wrap; opacity:.95}
    .btn{appearance:none; border:0; border-radius:999px; padding:.6rem 1rem; font-weight:700; color:#00121f; background:var(--accent); box-shadow:0 8px 18px rgba(82,214,122,.35); cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="420" height="640" aria-label="Pathy Finder top-down"></canvas>
    <div class="hud">
      <button id="flapBtn" class="btn" title="Space/Click/Tap">Flap</button>
      <button id="restartBtn" class="btn" title="Enter to restart">Restart</button>
      <span class="muted">Controls: Space / Click / Tap Â· Restart: Enter</span>
    </div>
  </div>

  <script>
  "use strict";

/*** TWEAKABLES *************************************************************/
// Path look
var PATH_ENABLED = true;
var PATH_WIDTH = 120;
var PATH_EDGE  = "#5c4426";
var PATH_FILL  = "#b89362";
var PATH_CENTER = "#d8c59d";
var PATH_CENTER_WIDTH = 72;
// Path generation / smoothness
var PATH_STEP = 12;
var PATH_EASE = 0.12;
var PATH_WOBBLE = 0.0;
// Forest floor density & motion
var FLOOR_SPRITES = 140;
var FLOOR_SPEED = 2.0;
// Win / degree collectible
var WIN_SCORE = 10;              // when the degree spawns
var DEGREE_TYPE = "auto";        // "cap", "diploma", or "auto"
var STOP_SPAWN_ON_DEGREE = true; // stop new pipes once degree appears
/***************************************************************************/

window.addEventListener('DOMContentLoaded', function(){
  // Debug overlay
  var errorOverlay = document.createElement('div');
  Object.assign(errorOverlay.style, {
    position:'fixed', top:'12px', left:'12px', background:'rgba(0,0,0,0.7)',
    color:'#fff', padding:'12px 14px', borderRadius:'12px', font:'14px system-ui',
    display:'none', zIndex:'9999', maxWidth:'640px'
  });
  document.body.appendChild(errorOverlay);
  function showError(msg){ errorOverlay.textContent = msg; errorOverlay.style.display = 'block'; console.error(msg); }

  // Canvas
  var canvas = document.getElementById('game');
  if(!canvas){ showError('Canvas #game not found'); return; }
  var ctx = canvas.getContext('2d');
  if(!ctx){ showError('2D context not available'); return; }

  // World
  var W = canvas.width, H = canvas.height;

  // Bird
  var bird = { x: 90, y: H*0.5, r: 14, vy: 0 };
  var GRAVITY = 0.45, FLAP = -7.6, MAX_FALL = 12;

  // Barriers (vertical hedges/logs)
  var pipes = [];
  var PIPE_W = 66, GAP_H = 160, PIPE_SPEED = 2.4, SPAWN_FRAMES = 95;

  // Sprites (optional)
  var BIRD_IMG_SRC = 'pathfinderheadNOBG.png';
  var PIPE_IMG_SRC = 'log.png';
  var CAP_IMG_SRC = 'cap.png';
  var DIPLOMA_IMG_SRC = 'diploma.png';

  var SPRITES = {
    bird:new Image(), pipe:new Image(), cap:new Image(), diploma:new Image(),
    birdReady:false, pipeReady:false, capReady:false, diplomaReady:false
  };
  if (BIRD_IMG_SRC){ SPRITES.bird.src=BIRD_IMG_SRC; SPRITES.bird.onload=()=>SPRITES.birdReady=true; SPRITES.bird.onerror=()=>{}; }
  if (PIPE_IMG_SRC){ SPRITES.pipe.src=PIPE_IMG_SRC; SPRITES.pipe.onload=()=>SPRITES.pipeReady=true; SPRITES.pipe.onerror=()=>{}; }
  if (CAP_IMG_SRC){ SPRITES.cap.src=CAP_IMG_SRC; SPRITES.cap.onload=()=>SPRITES.capReady=true; SPRITES.cap.onerror=()=>{}; }
  if (DIPLOMA_IMG_SRC){ SPRITES.diploma.src=DIPLOMA_IMG_SRC; SPRITES.diploma.onload=()=>SPRITES.diplomaReady=true; SPRITES.diploma.onerror=()=>{}; }

  var BIRD_SCALE = 2.0, PIPE_SCALE_X = 1.0;

  // State
  var frame=0, score=0, best=+(localStorage.getItem('best_flappy')||'0'), alive=true, started=false;
  var won = false;

  // Confetti
  var confetti = [];
  function spawnConfetti(n){
    confetti.length = 0;
    for (let i = 0; i < n; i++){
      confetti.push({
        x: Math.random() * W,
        y: -20 - Math.random() * 60,
        vx: (Math.random() * 2 - 1) * 1.5,
        vy: 2 + Math.random() * 2.5,
        vr: (Math.random() * 2 - 1) * 0.1,
        r: Math.random() * Math.PI * 2,
        size: 3 + Math.random() * 3,
        color: ['#ffd166','#ef476f','#06d6a0','#118ab2','#8338ec'][Math.floor(Math.random()*5)]
      });
    }
  }
  function updateConfetti(){
    for (let c of confetti){
      c.x += c.vx;
      c.y += c.vy;
      c.r += c.vr;
      if (c.y > H + 30){
        c.y = -30;
        c.x = Math.random() * W;
      }
    }
  }
  function drawConfetti(){
    for (let c of confetti){
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.r);
      ctx.fillStyle = c.color;
      ctx.fillRect(-c.size/2, -c.size/2, c.size, c.size);
      ctx.restore();
    }
  }

  // Top-down forest floor sprites
  var floor = [];
  function initFloor(){
    floor.length = 0;
    for(let i=0;i<FLOOR_SPRITES;i++){
      floor.push(spawnFloorSprite(Math.random()*W, Math.random()*H));
    }
  }
  function spawnFloorSprite(x,y){
    return {
      x:x, y:y,
      t: Math.random()<0.65?'leaf': (Math.random()<0.5?'rock':'mush'),
      s: 6 + Math.random()*10,
      r: Math.random()*Math.PI*2,
      a: 0.6 + Math.random()*0.4
    };
  }
  function updateFloor(){
    for(let s of floor){
      s.x -= FLOOR_SPEED;
      if(s.x < -20){
        s.x = W + Math.random()*60;
        s.y = 10 + Math.random()*(H-20);
        s.s = 6 + Math.random()*10;
        s.r = Math.random()*Math.PI*2;
        s.t = Math.random()<0.65?'leaf': (Math.random()<0.5?'rock':'mush');
        s.a = 0.6 + Math.random()*0.4;
      }
    }
  }
  function drawFloor(){
    let g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#2f5a33');
    g.addColorStop(1,'#224528');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // faint speckles
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<80;i++){
      let x = ((i*53 + frame*3) % (W+40)) - 20;
      let y = (i*97 % (H+40)) - 20;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // sprites
    for(let s of floor){
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.r);
      ctx.globalAlpha = s.a;

      if(s.t==='leaf'){
        ctx.fillStyle = '#7bbf5b';
        leafShape(s.s);
        ctx.fillStyle = '#4f8e3d';
        ctx.globalAlpha = s.a*0.4;
        leafVein(s.s);
      }else if(s.t==='rock'){
        ctx.fillStyle = '#8d8f8f';
        rockShape(s.s);
      }else{ // mush/flower
        ctx.fillStyle = '#d4c05b';
        rockShape(s.s*0.7);
        ctx.fillStyle = '#c94b4b';
        ctx.beginPath();
        ctx.arc(0, -s.s*0.3, s.s*0.35, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }
  function leafShape(sz){
    ctx.beginPath();
    ctx.moveTo(-sz*0.6,0);
    ctx.quadraticCurveTo(0,-sz*0.8, sz*0.6,0);
    ctx.quadraticCurveTo(0, sz*0.8,-sz*0.6,0);
    ctx.fill();
  }
  function leafVein(sz){
    ctx.beginPath();
    ctx.moveTo(-sz*0.5,0);
    ctx.lineTo(sz*0.5,0);
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  function rockShape(sz){
    ctx.beginPath();
    ctx.ellipse(0,0, sz*0.7, sz*0.5, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // -------- Persistent PATH (only extends on the right) --------------------
  var pathPts = [];       // [{x,y}] screen space; shift left each frame
  var currentY = H*0.5;   // evolving y
  var targetY  = H*0.5;   // slowly changing target
  var targetTimer = 0;

  function resetPath(){
    pathPts.length = 0;
    currentY = targetY = H*0.5;
    // fill across screen plus a right buffer
    let x = -60;
    while(x <= W+180){
      pushPathPoint(x);
      x += PATH_STEP;
    }
  }
  function pushPathPoint(x){
    if(targetTimer<=0){
      targetTimer = 18 + (Math.random()*18|0);
      targetY += (Math.random()*2-1) * 80; // step
      let minY = 60, maxY = H-60;
      if(targetY < minY) targetY = minY + (minY-targetY)*0.3;
      if(targetY > maxY) targetY = maxY - (targetY-maxY)*0.3;
    }
    targetTimer--;

    currentY += (targetY - currentY) * PATH_EASE;
    if(PATH_WOBBLE>0){
      currentY += Math.sin((x+frame)*0.02) * PATH_WOBBLE;
    }
    pathPts.push({x:x, y:currentY});
  }
  function advancePath(){
    for(let p of pathPts){ p.x -= PIPE_SPEED; }
    while(pathPts.length && pathPts[0].x < -120){ pathPts.shift(); }
    let lastX = pathPts.length ? pathPts[pathPts.length-1].x : -60;
    while(lastX <= W+180){
      lastX += PATH_STEP;
      pushPathPoint(lastX);
    }
  }
  function getPathYAt(x){
    for(let i=0;i<pathPts.length-1;i++){
      let a = pathPts[i], b = pathPts[i+1];
      if(x >= a.x && x <= b.x){
        let t = (x - a.x) / (b.x - a.x);
        return a.y + (b.y - a.y)*t;
      }
    }
    return pathPts.length ? pathPts[pathPts.length-1].y : H*0.5;
  }
  function drawPath(){
    if(!PATH_ENABLED || pathPts.length<2) return;

    function drawSmooth(strokeStyle, width){
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = width;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(pathPts[0].x, pathPts[0].y);
      for(let i=0;i<pathPts.length-1;i++){
        let p0 = pathPts[i], p1 = pathPts[i+1];
        let mx = (p0.x + p1.x)/2, my = (p0.y + p1.y)/2;
        ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
      }
      let L = pathPts.length-1;
      ctx.quadraticCurveTo(pathPts[L-1].x, pathPts[L-1].y, pathPts[L].x, pathPts[L].y);
      ctx.stroke();
    }

    drawSmooth(PATH_EDGE, PATH_WIDTH);
    drawSmooth(PATH_FILL, Math.max(1, PATH_WIDTH*0.8));
    drawSmooth(PATH_CENTER, PATH_CENTER_WIDTH);
  }

  // ------------------- Degree collectible ---------------------------------
  var degree = null;           // {x,y,type,size,hitR,sparkles:[...]}
  var degreeSpawned = false;
  var degreeCollected = false;

  function chooseDegreeType(){
    if (DEGREE_TYPE === "auto") return Math.random() < 0.5 ? "cap" : "diploma";
    return (DEGREE_TYPE === "cap" || DEGREE_TYPE === "diploma") ? DEGREE_TYPE : "cap";
  }

  function spawnDegree(){
    degreeSpawned = true;
    degreeCollected = false;
    const x = W + 120;
    const y = getPathYAt(x);
    const type = chooseDegreeType();
    const size = 30;
    const hitR = 18;

    // sparkles that orbit around the degree
    const sparkles = [];
    for (let i=0;i<14;i++){
      sparkles.push({
        a: (Math.PI*2*i)/14,
        r: 26 + Math.random()*6,
        w: 0.02 + Math.random()*0.03,  // angular speed
        s: 2 + Math.random()*2,        // size
        yoff: (Math.random()*2-1)*1.5,
        color: ['#fff2a8','#ffe3b0','#ffffff'][Math.floor(Math.random()*3)]
      });
    }

    degree = { x, y, type, size, hitR, sparkles };
  }

  function updateDegree(){
    if (!degree) return;
    degree.x -= PIPE_SPEED;

    // keep it glued to the path center as it scrolls
    degree.y = getPathYAt(degree.x);

    // update sparkles
    for (let sp of degree.sparkles){
      sp.a += sp.w;
    }

    // offscreen fail-safe
    if (degree.x < -80) { degree = null; }
  }

  function drawDegree(){
    if (!degree) return;

    // draw sparkle ring first
    for (let sp of degree.sparkles){
      const sx = degree.x + Math.cos(sp.a) * sp.r;
      const sy = degree.y + Math.sin(sp.a) * (sp.r*0.45) + sp.yoff;
      ctx.fillStyle = sp.color;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(sx, sy - sp.s);
      ctx.lineTo(sx + sp.s, sy);
      ctx.lineTo(sx, sy + sp.s);
      ctx.lineTo(sx - sp.s, sy);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.save();
    ctx.translate(degree.x, degree.y);

    if (degree.type === "cap"){
      if (SPRITES.capReady){
        const d = degree.size*1.6;
        ctx.drawImage(SPRITES.cap, -d/2, -d/2, d, d);
      } else {
        drawCapFallback(degree.size);
      }
    } else {
      if (SPRITES.diplomaReady){
        const d = degree.size*1.6;
        ctx.drawImage(SPRITES.diploma, -d/2, -d/2, d, d);
      } else {
        drawDiplomaFallback(degree.size);
      }
    }
    ctx.restore();
  }

  function drawCapFallback(s){
    // mortarboard
    ctx.save();
    ctx.rotate(-0.1);
    ctx.fillStyle = '#1c1c24';
    ctx.beginPath();
    ctx.moveTo(-s, 0); ctx.lineTo(0, -s*0.65); ctx.lineTo(s, 0); ctx.lineTo(0, s*0.65); ctx.closePath();
    ctx.fill();
    // button
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
    // tassel
    ctx.strokeStyle = '#e5c14a'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(s*0.5, s*0.15, s*0.2, s*0.9); ctx.stroke();
    ctx.restore();
  }

  function drawDiplomaFallback(s){
    // scroll body
    ctx.fillStyle = '#f4f0d8';
    roundRect(-s*0.9, -s*0.35, s*1.8, s*0.7, 6, true);
    // end shadows
    ctx.fillStyle = '#d7d0b6';
    roundRect(-s*0.95, -s*0.35, s*0.2, s*0.7, 6, true);
    roundRect(s*0.75, -s*0.35, s*0.2, s*0.7, 6, true);
    // ribbon
    ctx.fillStyle = '#c94b4b';
    roundRect(-s*0.25, -s*0.18, s*0.5, s*0.36, 4, true);
  }

  function roundRect(x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    if(fill) ctx.fill(); else ctx.stroke();
  }

  function birdDegreeCollision(){
    if (!degree) return false;
    const dx = bird.x - degree.x;
    const dy = bird.y - degree.y;
    const rr = (bird.r + degree.hitR);
    return (dx*dx + dy*dy) <= rr*rr;
  }

  // ------------------- Game core ------------------------------------------
  function reset(){
    pipes.length = 0;
    bird.y = H*0.5; bird.vy = 0;
    frame = 0; score = 0; alive = true; started = false;
    won = false;
    confetti.length = 0;

    degree = null;
    degreeSpawned = false;
    degreeCollected = false;

    initFloor();
    resetPath();
  }

  function spawnPipe(){
    var xSpawn = W + 10;
    var pipeW = PIPE_W * PIPE_SCALE_X;
    var centerY = getPathYAt(xSpawn + pipeW*0.5);
    var margin = 50;
    var topHeight = Math.max(margin, Math.min(centerY - GAP_H/2, H - GAP_H - margin));
    pipes.push({ x:xSpawn, gapY: topHeight, passed:false });
  }

  function flap(){ if(!alive) return; started = true; bird.vy = FLAP; }

  function update(){
    if(alive && started){
      bird.vy = Math.min(bird.vy + GRAVITY, MAX_FALL);
      bird.y += bird.vy;

      advancePath();
      updateFloor();

      // Spawn pipes unless degree is on the field (to keep the pickup clear)
      if(!degreeSpawned){
        if(frame % SPAWN_FRAMES === 0){ spawnPipe(); }
      }
      for(let p of pipes){ p.x -= PIPE_SPEED; }
      while(pipes.length && pipes[0].x + PIPE_W < -20){ pipes.shift(); }

      // scoring
      for(let p of pipes){
        if(!p.passed && p.x + PIPE_W < bird.x - bird.r){
          p.passed = true;
          score++;
          best = Math.max(best, score);
          localStorage.setItem('best_flappy', String(best));
        }
      }

      // Degree spawn condition
      if (!degreeSpawned && score >= WIN_SCORE){
        spawnDegree();
      }

      // Degree update + collection
      if (degreeSpawned && degree && !degreeCollected){
        updateDegree();
        if (birdDegreeCollision()){
          degreeCollected = true;
          won = true;
          alive = false;        // end with celebration
          spawnConfetti(160);
        }
      }

      // bounds
      if(bird.y - bird.r < 0){ bird.y = bird.r; bird.vy = 0; }
      if(bird.y + bird.r > H){ alive = false; }

      // collisions (only if we haven't already won)
      if (!won){
        for(let pk of pipes){
          let topRect = { x:pk.x, y:0, w:PIPE_W*PIPE_SCALE_X, h:pk.gapY };
          let botRect = { x:pk.x, y:pk.gapY + GAP_H, w:PIPE_W*PIPE_SCALE_X, h:H - (pk.gapY + GAP_H) };
          if(circleIntersectsRect(bird.x, bird.y, bird.r, topRect) || circleIntersectsRect(bird.x, bird.y, bird.r, botRect)){
            alive = false; break;
          }
        }
      }
    }

    // keep confetti animating on win screen
    if (won) { updateConfetti(); }

    frame++;
  }

  function circleIntersectsRect(cx, cy, r, rect){
    var x=rect.x, y=rect.y, w=rect.w, h=rect.h;
    var nx = Math.max(x, Math.min(cx, x+w));
    var ny = Math.max(y, Math.min(cy, y+h));
    var dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) < r*r;
  }

  function drawPipes(){
    for(let p of pipes){
      let pipeW = PIPE_W * PIPE_SCALE_X;
      let topH = p.gapY;
      let botY = p.gapY + GAP_H;
      let botH = H - botY;

      if (SPRITES.pipeReady){
        // top chunk (flip)
        ctx.save();
        ctx.translate(p.x + pipeW/2, topH/2);
        ctx.scale(1,-1);
        ctx.drawImage(SPRITES.pipe, -pipeW/2, -topH/2, pipeW, topH);
        ctx.restore();
        // bottom chunk
        ctx.drawImage(SPRITES.pipe, p.x, botY, pipeW, botH);
      } else {
        // hedge/wall colors
        let g = ctx.createLinearGradient(p.x,0,p.x+pipeW,0);
        g.addColorStop(0,'#2d6b3b'); g.addColorStop(1,'#3c8d4c');
        ctx.fillStyle = g;
        ctx.fillRect(p.x, 0, pipeW, topH);
        ctx.fillRect(p.x, botY, pipeW, botH);
        // shadow lips
        ctx.fillStyle = 'rgba(0,0,0,.10)';
        ctx.fillRect(p.x-2, topH-8, pipeW+4, 8);
        ctx.fillRect(p.x-2, botY, pipeW+4, 8);
      }
    }
  }

  function drawBird(){
    ctx.save();
    ctx.translate(bird.x, bird.y);
    let tilt = Math.max(-0.6, Math.min(0.6, bird.vy/10));
    ctx.rotate(tilt);

    if (SPRITES.birdReady){
      let w = (bird.r*2)*BIRD_SCALE, h = w;
      ctx.drawImage(SPRITES.bird, -w/2, -h/2, w, h);
    } else {
      // top-down marker
      ctx.fillStyle = '#ffd166';
      ctx.beginPath(); ctx.arc(0,0,bird.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff9f1a';
      ctx.beginPath(); ctx.arc(bird.r*0.6,0, bird.r*0.25, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawHUD(){
    // Score box
    ctx.fillStyle = 'rgba(0,0,0,.25)';
    ctx.fillRect(8,8,180,56);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Score: '+score, 16, 32);
    ctx.fillText('Best:  '+best, 16, 56);

    // Hint when degree is out
    if (degreeSpawned && !won && alive){
      ctx.textAlign = 'center';
      ctx.font = 'bold 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('ðŸŽ“ Grab your degree!', W/2, 36);
      ctx.textAlign = 'left';
    }

    // Start screen
    if(!started){
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 26px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Welcome to Pathy Finder!', W/2, H/2 - 36);
      ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Follow the path through the forest floor!', W/2, H/2 - 6);
      ctx.fillText('Tap / Click / Space to start', W/2, H/2 + 24);
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
    }

    // End screens
    if(!alive){
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,W,H);

      // Confetti above overlay if won
      if (won) { drawConfetti(); }

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (won) {
        // WIN SCREEN
        ctx.font = 'bold 30px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('ðŸŽ“ Degree Earned!', W/2, H/2 - 70);

        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        const lines = [
          "You navigated the whole path.",
          "Pathfinder would be proud!"
        ];
        const lh = 26;
        lines.forEach((t,i)=> ctx.fillText(t, W/2, H/2 - 24 + i*lh));

      } else {
        // POSITIVE GAME-OVER
        ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('Oh no!', W/2, H/2 - 70);
        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        const lines = [
          "Sometimes things don't go the way we hoped.",
          "That's okay!",
          "Dust yourself off and try again!"
        ];
        const lh = 26;
        lines.forEach((t,i)=> ctx.fillText(t, W/2, H/2 - 24 + i*lh));
      }

      ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Press Enter or click Restart', W/2, H/2 + 84);

      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawFloor();
    if(PATH_ENABLED) drawPath();
    drawPipes();
    // draw degree above pipes so it's always visible
    drawDegree();
    drawBird();
    drawHUD();
  }

  function loop(){ update(); render(); requestAnimationFrame(loop); }

  // Input
  function onKey(e){
    let code = e.code || e.key;
    if(code==='Space'){ e.preventDefault(); flap(); }
    else if(code==='ArrowUp'){ flap(); }
    else if(code==='Enter'){ if(!alive){ reset(); } }
  }
  function onPointer(){ if(alive){ flap(); } }

  document.addEventListener('keydown', onKey);
  canvas.addEventListener('pointerdown', onPointer);
  document.getElementById('flapBtn')?.addEventListener('click', flap);
  document.getElementById('restartBtn')?.addEventListener('click', reset);
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ started=false; } });

  // go
  reset();
  loop();
});

  </script>
</body>
</html>
