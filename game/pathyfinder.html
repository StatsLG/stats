<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pathy Finder (Top-Down)</title>
  <style>
    :root{ --fg:#e8f0fe; --muted:#9fb3c8; --accent:#52d67a; }
    html,body{height:100%}
    body{
      margin:0; background:#0b1320; color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
      display:grid; place-items:center
    }
    .wrap{display:flex; flex-direction:column; gap:.75rem; align-items:center}
    canvas{
      background:#254228; /* fully painted each frame; safety color */
      border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      touch-action:none
    }
    .hud{display:flex; gap:.75rem; align-items:center; justify-content:center; flex-wrap:wrap; opacity:.95}
    .btn{appearance:none; border:0; border-radius:999px; padding:.6rem 1rem; font-weight:700; color:#00121f; background:var(--accent); box-shadow:0 8px 18px rgba(82,214,122,.35); cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="420" height="640" aria-label="Pathy Finder top-down"></canvas>
    <div class="hud">
      <button id="flapBtn" class="btn" title="Space/Click/Tap">Flap</button>
      <button id="restartBtn" class="btn" title="Enter to restart">Restart</button>
      <span class="muted">Controls: Space / Click / Tap Â· Restart: Enter</span>
    </div>
  </div>

  <script>
  "use strict";

/*** TWEAKABLES *************************************************************/
// Path look
var PATH_ENABLED = true;
var PATH_WIDTH = 120;           // total road edge width (outer stroke)
var PATH_EDGE  = "#5c4426";    // darker rim
var PATH_FILL  = "#b89362";    // inner dirt
var PATH_CENTER = "#d8c59d";   // dusty center highlight
var PATH_CENTER_WIDTH = 72;    // keep < PATH_WIDTH
// Path generation / smoothness
var PATH_STEP = 12;            // px between generated samples (smaller = smoother)
var PATH_EASE = 0.12;          // how fast currentY approaches targetY (0.08â€“0.18 nice)
var PATH_WOBBLE = 0.0;         // tiny sinus wobble amount (0â€“2)
// Forest floor density & motion
var FLOOR_SPRITES = 140;       // leaves/rocks count
var FLOOR_SPEED = 2.0;         // floor drift speed (top-down feel)
// Win condition
var WIN_SCORE = 10;            // target score to "earn a degree"
/***************************************************************************/

window.addEventListener('DOMContentLoaded', function(){
  // Debug overlay
  var errorOverlay = document.createElement('div');
  Object.assign(errorOverlay.style, {
    position:'fixed', top:'12px', left:'12px', background:'rgba(0,0,0,0.7)',
    color:'#fff', padding:'12px 14px', borderRadius:'12px', font:'14px system-ui',
    display:'none', zIndex:'9999', maxWidth:'640px'
  });
  document.body.appendChild(errorOverlay);
  function showError(msg){ errorOverlay.textContent = msg; errorOverlay.style.display = 'block'; console.error(msg); }

  // Canvas
  var canvas = document.getElementById('game');
  if(!canvas){ showError('Canvas #game not found'); return; }
  var ctx = canvas.getContext('2d');
  if(!ctx){ showError('2D context not available'); return; }

  // World
  var W = canvas.width, H = canvas.height;
  var GROUND_H = 0; // top-down: no ground band

  // Bird
  var bird = { x: 90, y: H*0.5, r: 14, vy: 0 };
  var GRAVITY = 0.45, FLAP = -7.6, MAX_FALL = 12;

  // Barriers (vertical hedges/logs)
  var pipes = [];
  var PIPE_W = 66, GAP_H = 160, PIPE_SPEED = 2.4, SPAWN_FRAMES = 95;

  // Sprites (optional)
  var BIRD_IMG_SRC = 'pathfinderheadNOBG.png';
  var PIPE_IMG_SRC = 'log.png';
  var SPRITES = { bird:new Image(), pipe:new Image(), birdReady:false, pipeReady:false };
  if (BIRD_IMG_SRC){ SPRITES.bird.src=BIRD_IMG_SRC; SPRITES.bird.onload=()=>SPRITES.birdReady=true; SPRITES.bird.onerror=()=>{}; }
  if (PIPE_IMG_SRC){ SPRITES.pipe.src=PIPE_IMG_SRC; SPRITES.pipe.onload=()=>SPRITES.pipeReady=true; SPRITES.pipe.onerror=()=>{}; }
  var BIRD_SCALE = 2.0, PIPE_SCALE_X = 1.0;

  // State
  var frame=0, score=0, best=+(localStorage.getItem('best_flappy')||'0'), alive=true, started=false;
  var won = false;

  // Confetti
  var confetti = [];
  function spawnConfetti(n){
    confetti.length = 0;
    for (let i = 0; i < n; i++){
      confetti.push({
        x: Math.random() * W,
        y: -20 - Math.random() * 60,
        vx: (Math.random() * 2 - 1) * 1.5,
        vy: 2 + Math.random() * 2.5,
        vr: (Math.random() * 2 - 1) * 0.1,
        r: Math.random() * Math.PI * 2,
        size: 3 + Math.random() * 3,
        color: ['#ffd166','#ef476f','#06d6a0','#118ab2','#8338ec'][Math.floor(Math.random()*5)]
      });
    }
  }
  function updateConfetti(){
    for (let c of confetti){
      c.x += c.vx;
      c.y += c.vy;
      c.r += c.vr;
      if (c.y > H + 30){
        c.y = -30;
        c.x = Math.random() * W;
      }
    }
  }
  function drawConfetti(){
    for (let c of confetti){
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.r);
      ctx.fillStyle = c.color;
      ctx.fillRect(-c.size/2, -c.size/2, c.size, c.size);
      ctx.restore();
    }
  }

  // Top-down forest floor sprites
  var floor = [];
  function initFloor(){
    floor.length = 0;
    for(let i=0;i<FLOOR_SPRITES;i++){
      floor.push(spawnFloorSprite(Math.random()*W, Math.random()*H));
    }
  }
  function spawnFloorSprite(x,y){
    return {
      x:x, y:y,
      t: Math.random()<0.65?'leaf': (Math.random()<0.5?'rock':'mush'),
      s: 6 + Math.random()*10,
      r: Math.random()*Math.PI*2,
      a: 0.6 + Math.random()*0.4
    };
  }
  function updateFloor(){
    for(let s of floor){
      s.x -= FLOOR_SPEED;
      if(s.x < -20){
        s.x = W + Math.random()*60;
        s.y = 10 + Math.random()*(H-20);
        s.s = 6 + Math.random()*10;
        s.r = Math.random()*Math.PI*2;
        s.t = Math.random()<0.65?'leaf': (Math.random()<0.5?'rock':'mush');
        s.a = 0.6 + Math.random()*0.4;
      }
    }
  }
  function drawFloor(){
    let g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#2f5a33');
    g.addColorStop(1,'#224528');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // faint speckles
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<80;i++){
      let x = ((i*53 + frame*3) % (W+40)) - 20;
      let y = (i*97 % (H+40)) - 20;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // sprites
    for(let s of floor){
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.r);
      ctx.globalAlpha = s.a;

      if(s.t==='leaf'){
        ctx.fillStyle = '#7bbf5b';
        leafShape(s.s);
        ctx.fillStyle = '#4f8e3d';
        ctx.globalAlpha = s.a*0.4;
        leafVein(s.s);
      }else if(s.t==='rock'){
        ctx.fillStyle = '#8d8f8f';
        rockShape(s.s);
      }else{ // mush/flower
        ctx.fillStyle = '#d4c05b';
        rockShape(s.s*0.7);
        ctx.fillStyle = '#c94b4b';
        ctx.beginPath();
        ctx.arc(0, -s.s*0.3, s.s*0.35, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }
  function leafShape(sz){
    ctx.beginPath();
    ctx.moveTo(-sz*0.6,0);
    ctx.quadraticCurveTo(0,-sz*0.8, sz*0.6,0);
    ctx.quadraticCurveTo(0, sz*0.8,-sz*0.6,0);
    ctx.fill();
  }
  function leafVein(sz){
    ctx.beginPath();
    ctx.moveTo(-sz*0.5,0);
    ctx.lineTo(sz*0.5,0);
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  function rockShape(sz){
    ctx.beginPath();
    ctx.ellipse(0,0, sz*0.7, sz*0.5, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // -------- Persistent PATH (only extends on the right) --------------------
  var pathPts = [];       // [{x,y}] screen space; shift left each frame
  var currentY = H*0.5;   // evolving y
  var targetY  = H*0.5;   // slowly changing target
  var targetTimer = 0;

  function resetPath(){
    pathPts.length = 0;
    currentY = targetY = H*0.5;
    // fill across screen plus a right buffer
    let x = -60;
    while(x <= W+180){
      pushPathPoint(x);
      x += PATH_STEP;
    }
  }
  function pushPathPoint(x){
    if(targetTimer<=0){
      targetTimer = 18 + (Math.random()*18|0);
      targetY += (Math.random()*2-1) * 80; // step
      let minY = 60, maxY = H-60;
      if(targetY < minY) targetY = minY + (minY-targetY)*0.3;
      if(targetY > maxY) targetY = maxY - (targetY-maxY)*0.3;
    }
    targetTimer--;

    currentY += (targetY - currentY) * PATH_EASE;
    if(PATH_WOBBLE>0){
      currentY += Math.sin((x+frame)*0.02) * PATH_WOBBLE;
    }
    pathPts.push({x:x, y:currentY});
  }
  function advancePath(){
    for(let p of pathPts){ p.x -= PIPE_SPEED; }
    while(pathPts.length && pathPts[0].x < -120){ pathPts.shift(); }
    let lastX = pathPts.length ? pathPts[pathPts.length-1].x : -60;
    while(lastX <= W+180){
      lastX += PATH_STEP;
      pushPathPoint(lastX);
    }
  }
  function getPathYAt(x){
    for(let i=0;i<pathPts.length-1;i++){
      let a = pathPts[i], b = pathPts[i+1];
      if(x >= a.x && x <= b.x){
        let t = (x - a.x) / (b.x - a.x);
        return a.y + (b.y - a.y)*t;
      }
    }
    return pathPts.length ? pathPts[pathPts.length-1].y : H*0.5;
  }
  function drawPath(){
    if(!PATH_ENABLED || pathPts.length<2) return;

    function drawSmooth(strokeStyle, width){
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = width;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(pathPts[0].x, pathPts[0].y);
      for(let i=0;i<pathPts.length-1;i++){
        let p0 = pathPts[i], p1 = pathPts[i+1];
        let mx = (p0.x + p1.x)/2, my = (p0.y + p1.y)/2;
        ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
      }
      let L = pathPts.length-1;
      ctx.quadraticCurveTo(pathPts[L-1].x, pathPts[L-1].y, pathPts[L].x, pathPts[L].y);
      ctx.stroke();
    }

    drawSmooth(PATH_EDGE, PATH_WIDTH);
    drawSmooth(PATH_FILL, Math.max(1, PATH_WIDTH*0.8));
    drawSmooth(PATH_CENTER, PATH_CENTER_WIDTH);
  }

  // ------------------- Game core ------------------------------------------
  function reset(){
    pipes.length = 0;
    bird.y = H*0.5; bird.vy = 0;
    frame = 0; score = 0; alive = true; started = false;
    won = false;
    confetti.length = 0;
    initFloor();
    resetPath();
  }

  function spawnPipe(){
    var xSpawn = W + 10;
    var pipeW = PIPE_W * PIPE_SCALE_X;
    var centerY = getPathYAt(xSpawn + pipeW*0.5);
    var margin = 50;
    var topHeight = Math.max(margin, Math.min(centerY - GAP_H/2, H - GROUND_H - GAP_H - margin));
    pipes.push({ x:xSpawn, gapY: topHeight, passed:false });
  }

  function flap(){ if(!alive) return; started = true; bird.vy = FLAP; }

  function update(){
    if(alive && started){
      bird.vy = Math.min(bird.vy + GRAVITY, MAX_FALL);
      bird.y += bird.vy;

      advancePath();
      updateFloor();

      if(frame % SPAWN_FRAMES === 0){ spawnPipe(); }
      for(let p of pipes){ p.x -= PIPE_SPEED; }
      while(pipes.length && pipes[0].x + PIPE_W < -20){ pipes.shift(); }

      for(let p of pipes){
        if(!p.passed && p.x + PIPE_W < bird.x - bird.r){
          p.passed = true;
          score++;
          best = Math.max(best, score);
          localStorage.setItem('best_flappy', String(best));

          // Win check
          if (score >= WIN_SCORE && !won){
            won = true;
            alive = false;        // end the run with ceremony
            spawnConfetti(140);
          }
        }
      }

      if(bird.y - bird.r < 0){ bird.y = bird.r; bird.vy = 0; }
      if(bird.y + bird.r > H - GROUND_H){ alive = false; }

      // collisions
      for(let pk of pipes){
        let topRect = { x:pk.x, y:0, w:PIPE_W*PIPE_SCALE_X, h:pk.gapY };
        let botRect = { x:pk.x, y:pk.gapY + GAP_H, w:PIPE_W*PIPE_SCALE_X, h:H - GROUND_H - (pk.gapY + GAP_H) };
        if(circleIntersectsRect(bird.x, bird.y, bird.r, topRect) || circleIntersectsRect(bird.x, bird.y, bird.r, botRect)){
          alive = false; break;
        }
      }
    }

    // keep confetti animating on win screen
    if (won) { updateConfetti(); }

    frame++;
  }

  function circleIntersectsRect(cx, cy, r, rect){
    var x=rect.x, y=rect.y, w=rect.w, h=rect.h;
    var nx = Math.max(x, Math.min(cx, x+w));
    var ny = Math.max(y, Math.min(cy, y+h));
    var dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) < r*r;
  }

  function drawPipes(){
    for(let p of pipes){
      let pipeW = PIPE_W * PIPE_SCALE_X;
      let topH = p.gapY;
      let botY = p.gapY + GAP_H;
      let botH = H - GROUND_H - botY;

      if (SPRITES.pipeReady){
        // top chunk (flip)
        ctx.save();
        ctx.translate(p.x + pipeW/2, topH/2);
        ctx.scale(1,-1);
        ctx.drawImage(SPRITES.pipe, -pipeW/2, -topH/2, pipeW, topH);
        ctx.restore();
        // bottom chunk
        ctx.drawImage(SPRITES.pipe, p.x, botY, pipeW, botH);
      } else {
        // hedge/wall colors
        let g = ctx.createLinearGradient(p.x,0,p.x+pipeW,0);
        g.addColorStop(0,'#2d6b3b'); g.addColorStop(1,'#3c8d4c');
        ctx.fillStyle = g;
        ctx.fillRect(p.x, 0, pipeW, topH);
        ctx.fillRect(p.x, botY, pipeW, botH);
        // shadow lips
        ctx.fillStyle = 'rgba(0,0,0,.10)';
        ctx.fillRect(p.x-2, topH-8, pipeW+4, 8);
        ctx.fillRect(p.x-2, botY, pipeW+4, 8);
      }
    }
  }

  function drawBird(){
    ctx.save();
    ctx.translate(bird.x, bird.y);
    let tilt = Math.max(-0.6, Math.min(0.6, bird.vy/10));
    ctx.rotate(tilt);

    if (SPRITES.birdReady){
      let w = (bird.r*2)*BIRD_SCALE, h = w;
      ctx.drawImage(SPRITES.bird, -w/2, -h/2, w, h);
    } else {
      // top-down marker
      ctx.fillStyle = '#ffd166';
      ctx.beginPath(); ctx.arc(0,0,bird.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff9f1a';
      ctx.beginPath(); ctx.arc(bird.r*0.6,0, bird.r*0.25, 0, Math.PI*2); ctx.fill(); // "beak" dot
    }
    ctx.restore();
  }

  function drawHUD(){
    // Score box (only when alive & started, or you can show always)
    ctx.fillStyle = 'rgba(0,0,0,.25)';
    ctx.fillRect(8,8,120,56);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Score: '+score, 16, 32);
    ctx.fillText('Best:  '+best, 16, 56);

    // Start screen
    if(!started){
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 26px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Welcome to Pathy Finder!', W/2, H/2 - 36);
      ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Follow the path through the forest floor!', W/2, H/2 - 6);
      ctx.fillText('Tap / Click / Space to start', W/2, H/2 + 24);
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
    }

    // End screens
    if(!alive){
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,W,H);

      // Confetti above overlay if won
      if (won) { drawConfetti(); }

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (won) {
        // WIN SCREEN
        ctx.font = 'bold 30px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('ðŸŽ“ Degree Earned!', W/2, H/2 - 70);

        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        const lines = [
          "You navigated the whole path.",
          "Pathfinder would be proud!"
        ];
        const lh = 26;
        lines.forEach((t,i)=> ctx.fillText(t, W/2, H/2 - 24 + i*lh));

      } else {
        // POSITIVE GAME-OVER
        ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('Oh no!', W/2, H/2 - 70);
        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        const lines = [
          "Sometimes things don't go the way we hoped.",
          "That's okay!",
          "Dust yourself off and try again!"
        ];
        const lh = 26;
        lines.forEach((t,i)=> ctx.fillText(t, W/2, H/2 - 24 + i*lh));
      }

      ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Press Enter or click Restart', W/2, H/2 + 84);

      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawFloor();             // top-down forest floor
    if(PATH_ENABLED) drawPath(); // dirt path underneath barriers
    drawPipes();
    drawBird();
    drawHUD();
  }

  function loop(){ update(); render(); requestAnimationFrame(loop); }

  // Input
  function onKey(e){
    let code = e.code || e.key;
    if(code==='Space'){ e.preventDefault(); flap(); }
    else if(code==='ArrowUp'){ flap(); }
    else if(code==='Enter'){ if(!alive){ reset(); } }
  }
  function onPointer(){ if(alive){ flap(); } }

  document.addEventListener('keydown', onKey);
  canvas.addEventListener('pointerdown', onPointer);
  document.getElementById('flapBtn')?.addEventListener('click', flap);
  document.getElementById('restartBtn')?.addEventListener('click', reset);
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ started=false; } });

  // go
  reset();
  loop();
});
  </script>
</body>
</html>
