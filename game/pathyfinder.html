<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pathy Finder ‚Äî BCTC</title>

  <!-- Use your sitewide brand CSS -->
  <link rel="stylesheet" href="/style/bctcstyle.css">

  <style>
    /* Game-specific light wrapper that uses your brand tokens */
    .game-shell{
      min-height:100dvh; display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:12px; padding:18px;
      background: var(--bg);
      color: var(--ink);
    }
    .game-card{
      background: var(--card);
      border: 2px solid var(--kctcs-gold);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: var(--shadow-1);
    }
    canvas#game{
      display:block;
      border-radius: 16px;
      border: 2px solid var(--kctcs-blue);
      box-shadow: var(--shadow-2);
      touch-action:none;
      background:#ffffff; /* canvas is fully painted each frame, but white fits brand */
    }
    .hud{
      display:flex; gap:.5rem; align-items:center; justify-content:center; flex-wrap:wrap;
    }
    .muted{ color: var(--muted); }
  </style>
</head>
<body>
  <div class="game-shell">
    <div class="game-card">
      <canvas id="game" width="420" height="640" aria-label="Pathy Finder"></canvas>
    </div>
    <div class="hud">
      <button id="flapBtn" class="btn" title="Space/Click/Tap">Flap</button>
      <button id="restartBtn" class="btn outline" title="Enter to restart">Restart</button>
      <span class="muted">Controls: Space / Click / Tap ¬∑ Restart: Enter</span>
    </div>
  </div>

  <script>
  "use strict";

/*** BRAND PALETTE ***********************************************************/
const BRAND_BLUE = "#00467f";   // KCTCS Blue
const BRAND_GOLD = "#e7a614";   // KCTCS Gold
const ACCENT_LIGHT = "#e6f1ff"; // light blue surface
const ACCENT_LINE  = "#c7defe"; // light blue border
const INK          = "#0f172a";

/*** TWEAKABLES **************************************************************/
// Path look (aligned to brand colors)
var PATH_ENABLED = true;
var PATH_WIDTH = 120;
var PATH_EDGE  = BRAND_BLUE;
var PATH_FILL  = "#2b6aa0";     // complementary mid blue to give depth
var PATH_CENTER = BRAND_GOLD;
var PATH_CENTER_WIDTH = 72;

// Path generation / smoothness
var PATH_STEP = 12;
var PATH_EASE = 0.12;
var PATH_WOBBLE = 0.0;

// Decorative ‚Äúfloor‚Äù density & motion
var FLOOR_SPRITES = 120;
var FLOOR_SPEED = 2.0;

// Win / degree collectible
var WIN_SCORE = 10;              // when the degree spawns
var DEGREE_TYPE = "auto";        // "cap", "diploma", or "auto"
var STOP_SPAWN_ON_DEGREE = true; // (kept; we stop extra clutter)
/****************************************************************************/

window.addEventListener('DOMContentLoaded', function(){
  // Debug overlay
  var errorOverlay = document.createElement('div');
  Object.assign(errorOverlay.style, {
    position:'fixed', top:'12px', left:'12px',
    background:'rgba(0,0,0,0.72)', color:'#fff',
    padding:'12px 14px', borderRadius:'12px', font:'14px system-ui',
    display:'none', zIndex:'9999', maxWidth:'640px'
  });
  document.body.appendChild(errorOverlay);
  function showError(msg){ errorOverlay.textContent = msg; errorOverlay.style.display = 'block'; console.error(msg); }

  // Canvas
  var canvas = document.getElementById('game');
  if(!canvas){ showError('Canvas #game not found'); return; }
  var ctx = canvas.getContext('2d');
  if(!ctx){ showError('2D context not available'); return; }

  // World
  var W = canvas.width, H = canvas.height;

  // Bird
  var bird = { x: 90, y: H*0.5, r: 14, vy: 0 };
  var GRAVITY = 0.45, FLAP = -7.6, MAX_FALL = 12;

  // Barriers (vertical planks)
  var pipes = [];
  var PIPE_W = 66, GAP_H = 160, PIPE_SPEED = 2.4, SPAWN_FRAMES = 95;

  // Sprites (optional)
  var BIRD_IMG_SRC = 'pathfinderheadNOBG.png';
  var PIPE_IMG_SRC = '';            // set your image if you like, otherwise fallback paint
  var CAP_IMG_SRC = 'cap.png';
  var DIPLOMA_IMG_SRC = 'diploma.png';

  var SPRITES = {
    bird:new Image(), pipe:new Image(), cap:new Image(), diploma:new Image(),
    birdReady:false, pipeReady:false, capReady:false, diplomaReady:false
  };
  if (BIRD_IMG_SRC){ SPRITES.bird.src=BIRD_IMG_SRC; SPRITES.bird.onload=()=>SPRITES.birdReady=true; }
  if (PIPE_IMG_SRC){ SPRITES.pipe.src=PIPE_IMG_SRC; SPRITES.pipe.onload=()=>SPRITES.pipeReady=true; }
  if (CAP_IMG_SRC){ SPRITES.cap.src=CAP_IMG_SRC; SPRITES.cap.onload=()=>SPRITES.capReady=true; }
  if (DIPLOMA_IMG_SRC){ SPRITES.diploma.src=DIPLOMA_IMG_SRC; SPRITES.diploma.onload=()=>SPRITES.diplomaReady=true; }

  var BIRD_SCALE = 2.0, PIPE_SCALE_X = 1.0;

  // State
  var frame=0, score=0, best=+(localStorage.getItem('best_flappy')||'0'), alive=true, started=false;
  var won = false;

  // Confetti (brand-aligned)
  var confetti = [];
  function brandConfettiColor(){
    const palette = [BRAND_GOLD, BRAND_BLUE, '#0ea5e9', '#22c55e', '#111827'];
    return palette[Math.floor(Math.random()*palette.length)];
  }
  function spawnConfetti(n){
    confetti.length = 0;
    for (let i = 0; i < n; i++){
      confetti.push({
        x: Math.random() * W,
        y: -20 - Math.random() * 60,
        vx: (Math.random() * 2 - 1) * 1.5,
        vy: 2 + Math.random() * 2.5,
        vr: (Math.random() * 2 - 1) * 0.1,
        r: Math.random() * Math.PI * 2,
        size: 3 + Math.random() * 3,
        color: brandConfettiColor()
      });
    }
  }
  function updateConfetti(){
    for (let c of confetti){
      c.x += c.vx; c.y += c.vy; c.r += c.vr;
      if (c.y > H + 30){ c.y = -30; c.x = Math.random() * W; }
    }
  }
  function drawConfetti(){
    for (let c of confetti){
      ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.r);
      ctx.fillStyle = c.color;
      ctx.fillRect(-c.size/2, -c.size/2, c.size, c.size);
      ctx.restore();
    }
  }

  // Light ‚Äúpaper‚Äù floor (brand blue tints)
  var floor = [];
  function initFloor(){
    floor.length = 0;
    for(let i=0;i<FLOOR_SPRITES;i++){
      floor.push(spawnFloorSprite(Math.random()*W, Math.random()*H));
    }
  }
  function spawnFloorSprite(x,y){
    return {
      x:x, y:y,
      t: Math.random()<0.55?'dot': (Math.random()<0.5?'diamond':'ring'),
      s: 4 + Math.random()*8,
      r: Math.random()*Math.PI*2,
      a: 0.6 + Math.random()*0.35
    };
  }
  function updateFloor(){
    for(let s of floor){
      s.x -= FLOOR_SPEED;
      if(s.x < -20){
        s.x = W + Math.random()*60;
        s.y = 10 + Math.random()*(H-20);
        s.s = 4 + Math.random()*8;
        s.r = Math.random()*Math.PI*2;
        s.t = Math.random()<0.55?'dot': (Math.random()<0.5?'diamond':'ring');
        s.a = 0.6 + Math.random()*0.35;
      }
    }
  }
  function drawFloor(){
    // soft vertical brand gradient
    let g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#f9fbff");
    g.addColorStop(1, "#eef5ff");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // faint speckles
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = INK;
    for(let i=0;i<80;i++){
      let x = ((i*53 + frame*3) % (W+40)) - 20;
      let y = (i*97 % (H+40)) - 20;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // brandy sprites
    for(let s of floor){
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.r);
      ctx.globalAlpha = s.a;

      if(s.t==='dot'){
        ctx.fillStyle = ACCENT_LIGHT;
        ctx.beginPath(); ctx.arc(0,0, s.s*0.45, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = ACCENT_LINE; ctx.globalAlpha = s.a*0.5;
        ctx.beginPath(); ctx.arc(0,0, s.s*0.6, 0, Math.PI*2); ctx.stroke();
      }else if(s.t==='diamond'){
        ctx.fillStyle = BRAND_BLUE;
        ctx.beginPath();
        ctx.moveTo(0,-s.s*0.5); ctx.lineTo(s.s*0.5,0); ctx.lineTo(0,s.s*0.5); ctx.lineTo(-s.s*0.5,0); ctx.closePath();
        ctx.fill();
      }else{ // ring
        ctx.strokeStyle = BRAND_GOLD; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0, s.s*0.5, 0, Math.PI*2); ctx.stroke();
      }

      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  // ---------------- Path ---------------------------------------------------
  var pathPts = [];
  var currentY = H*0.5;
  var targetY  = H*0.5;
  var targetTimer = 0;

  function resetPath(){
    pathPts.length = 0;
    currentY = targetY = H*0.5;
    let x = -60;
    while(x <= W+180){ pushPathPoint(x); x += PATH_STEP; }
  }
  function pushPathPoint(x){
    if(targetTimer<=0){
      targetTimer = 18 + (Math.random()*18|0);
      targetY += (Math.random()*2-1) * 80;
      let minY = 60, maxY = H-60;
      if(targetY < minY) targetY = minY + (minY-targetY)*0.3;
      if(targetY > maxY) targetY = maxY - (targetY-maxY)*0.3;
    }
    targetTimer--;
    currentY += (targetY - currentY) * PATH_EASE;
    if(PATH_WOBBLE>0){ currentY += Math.sin((x+frame)*0.02) * PATH_WOBBLE; }
    pathPts.push({x:x, y:currentY});
  }
  function advancePath(){
    for(let p of pathPts){ p.x -= PIPE_SPEED; }
    while(pathPts.length && pathPts[0].x < -120){ pathPts.shift(); }
    let lastX = pathPts.length ? pathPts[pathPts.length-1].x : -60;
    while(lastX <= W+180){ lastX += PATH_STEP; pushPathPoint(lastX); }
  }
  function getPathYAt(x){
    for(let i=0;i<pathPts.length-1;i++){
      let a = pathPts[i], b = pathPts[i+1];
      if(x >= a.x && x <= b.x){
        let t = (x - a.x) / (b.x - a.x);
        return a.y + (b.y - a.y)*t;
      }
    }
    return pathPts.length ? pathPts[pathPts.length-1].y : H*0.5;
  }
  function drawPath(){
    if(!PATH_ENABLED || pathPts.length<2) return;
    function drawSmooth(strokeStyle, width){
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = width;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(pathPts[0].x, pathPts[0].y);
      for(let i=0;i<pathPts.length-1;i++){
        let p0 = pathPts[i], p1 = pathPts[i+1];
        let mx = (p0.x + p1.x)/2, my = (p0.y + p1.y)/2;
        ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
      }
      let L = pathPts.length-1;
      ctx.quadraticCurveTo(pathPts[L-1].x, pathPts[L-1].y, pathPts[L].x, pathPts[L].y);
      ctx.stroke();
    }
    drawSmooth(PATH_EDGE, PATH_WIDTH);
    drawSmooth(PATH_FILL, Math.max(1, PATH_WIDTH*0.8));
    drawSmooth(PATH_CENTER, PATH_CENTER_WIDTH);
  }

  // ---------------- Degree collectible ------------------------------------
  var degree = null;
  var degreeSpawned = false;
  var degreeCollected = false;

  function chooseDegreeType(){
    if (DEGREE_TYPE === "auto") return Math.random() < 0.5 ? "cap" : "diploma";
    return (DEGREE_TYPE === "cap" || DEGREE_TYPE === "diploma") ? DEGREE_TYPE : "cap";
  }
  function spawnDegree(){
    degreeSpawned = true; degreeCollected = false;
    const x = W + 120;
    const y = getPathYAt(x);
    const type = chooseDegreeType();
    const size = 30;
    const hitR = 18;

    const sparkles = [];
    for (let i=0;i<14;i++){
      sparkles.push({
        a: (Math.PI*2*i)/14,
        r: 26 + Math.random()*6,
        w: 0.02 + Math.random()*0.03,
        s: 2 + Math.random()*2,
        yoff: (Math.random()*2-1)*1.5,
        color: [BRAND_GOLD, "#ffffff", ACCENT_LIGHT][Math.floor(Math.random()*3)]
      });
    }
    degree = { x, y, type, size, hitR, sparkles };
  }
  function updateDegree(){
    if (!degree) return;
    degree.x -= PIPE_SPEED;
    degree.y = getPathYAt(degree.x);
    for (let sp of degree.sparkles){ sp.a += sp.w; }
    if (degree.x < -80) { degree = null; }
  }
  function drawDegree(){
    if (!degree) return;
    // sparkles
    for (let sp of degree.sparkles){
      const sx = degree.x + Math.cos(sp.a) * sp.r;
      const sy = degree.y + Math.sin(sp.a) * (sp.r*0.45) + sp.yoff;
      ctx.fillStyle = sp.color; ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(sx, sy - sp.s);
      ctx.lineTo(sx + sp.s, sy);
      ctx.lineTo(sx, sy + sp.s);
      ctx.lineTo(sx - sp.s, sy);
      ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;
    }
    ctx.save(); ctx.translate(degree.x, degree.y);
    if (degree.type === "cap"){
      if (SPRITES.capReady){
        const d = degree.size*1.6;
        ctx.drawImage(SPRITES.cap, -d/2, -d/2, d, d);
      } else {
        drawCapFallback(degree.size);
      }
    } else {
      if (SPRITES.diplomaReady){
        const d = degree.size*1.6;
        ctx.drawImage(SPRITES.diploma, -d/2, -d/2, d, d);
      } else {
        drawDiplomaFallback(degree.size);
      }
    }
    ctx.restore();
  }
  function drawCapFallback(s){
    ctx.save(); ctx.rotate(-0.1);
    ctx.fillStyle = '#1c1c24';
    ctx.beginPath();
    ctx.moveTo(-s, 0); ctx.lineTo(0, -s*0.65); ctx.lineTo(s, 0); ctx.lineTo(0, s*0.65); ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
    // tassel in BRAND GOLD
    ctx.strokeStyle = BRAND_GOLD; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(s*0.5, s*0.15, s*0.2, s*0.9); ctx.stroke();
    ctx.restore();
  }
  function drawDiplomaFallback(s){
    ctx.fillStyle = '#f7f2df';
    roundRect(-s*0.9, -s*0.35, s*1.8, s*0.7, 6, true);
    ctx.fillStyle = '#e1d8bd';
    roundRect(-s*0.95, -s*0.35, s*0.2, s*0.7, 6, true);
    roundRect(s*0.75, -s*0.35, s*0.2, s*0.7, 6, true);
    // ribbon in BRAND BLUE
    ctx.fillStyle = BRAND_BLUE;
    roundRect(-s*0.25, -s*0.18, s*0.5, s*0.36, 4, true);
  }
  function roundRect(x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    if(fill) ctx.fill(); else ctx.stroke();
  }
  function birdDegreeCollision(){
    if (!degree) return false;
    const dx = bird.x - degree.x, dy = bird.y - degree.y;
    const rr = (bird.r + degree.hitR);
    return (dx*dx + dy*dy) <= rr*rr;
  }

  // ---------------- Core ---------------------------------------------------
  function reset(){
    pipes.length = 0;
    bird.y = H*0.5; bird.vy = 0;
    frame = 0; score = 0; alive = true; started = false;
    won = false; confetti.length = 0;
    degree = null; degreeSpawned = false; degreeCollected = false;
    initFloor(); resetPath();
  }
  function spawnPipe(){
    var xSpawn = W + 10;
    var pipeW = PIPE_W * PIPE_SCALE_X;
    var centerY = getPathYAt(xSpawn + pipeW*0.5);
    var margin = 50;
    var topHeight = Math.max(margin, Math.min(centerY - GAP_H/2, H - GAP_H - margin));
    pipes.push({ x:xSpawn, gapY: topHeight, passed:false });
  }
  function flap(){ if(!alive) return; started = true; bird.vy = FLAP; }

  function update(){
    if(alive && started){
      bird.vy = Math.min(bird.vy + GRAVITY, MAX_FALL);
      bird.y += bird.vy;

      advancePath();
      updateFloor();

      if(!degreeSpawned){
        if(frame % SPAWN_FRAMES === 0){ spawnPipe(); }
      }
      for(let p of pipes){ p.x -= PIPE_SPEED; }
      while(pipes.length && pipes[0].x + PIPE_W < -20){ pipes.shift(); }

      for(let p of pipes){
        if(!p.passed && p.x + PIPE_W < bird.x - bird.r){
          p.passed = true; score++; best = Math.max(best, score);
          localStorage.setItem('best_flappy', String(best));
        }
      }

      if (!degreeSpawned && score >= WIN_SCORE){ spawnDegree(); }
      if (degreeSpawned && degree && !degreeCollected){
        updateDegree();
        if (birdDegreeCollision()){
          degreeCollected = true; won = true; alive = false; spawnConfetti(160);
        }
      }

      if(bird.y - bird.r < 0){ bird.y = bird.r; bird.vy = 0; }
      if(bird.y + bird.r > H){ alive = false; }

      if (!won){
        for(let pk of pipes){
          let topRect = { x:pk.x, y:0, w:PIPE_W*PIPE_SCALE_X, h:pk.gapY };
          let botRect = { x:pk.x, y:pk.gapY + GAP_H, w:PIPE_W*PIPE_SCALE_X, h:H - (pk.gapY + GAP_H) };
          if(circleIntersectsRect(bird.x, bird.y, bird.r, topRect) || circleIntersectsRect(bird.x, bird.y, bird.r, botRect)){
            alive = false; break;
          }
        }
      }
    }
    if (won) { updateConfetti(); }
    frame++;
  }
  function circleIntersectsRect(cx, cy, r, rect){
    var x=rect.x, y=rect.y, w=rect.w, h=rect.h;
    var nx = Math.max(x, Math.min(cx, x+w));
    var ny = Math.max(y, Math.min(cy, y+h));
    var dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) < r*r;
  }

  function drawPipes(){
    for(let p of pipes){
      let pipeW = PIPE_W * PIPE_SCALE_X;
      let topH = p.gapY;
      let botY = p.gapY + GAP_H;
      let botH = H - botY;

      if (SPRITES.pipeReady){
        ctx.save();
        ctx.translate(p.x + pipeW/2, topH/2);
        ctx.scale(1,-1);
        ctx.drawImage(SPRITES.pipe, -pipeW/2, -topH/2, pipeW, topH);
        ctx.restore();
        ctx.drawImage(SPRITES.pipe, p.x, botY, pipeW, botH);
      } else {
        // brandy planks
        let g = ctx.createLinearGradient(p.x,0,p.x+pipeW,0);
        g.addColorStop(0, BRAND_BLUE);
        g.addColorStop(1, "#2b6aa0");
        ctx.fillStyle = g;
        ctx.fillRect(p.x, 0, pipeW, topH);
        ctx.fillRect(p.x, botY, pipeW, botH);
        // gold lips
        ctx.fillStyle = BRAND_GOLD + "88";
        ctx.fillRect(p.x-2, topH-8, pipeW+4, 8);
        ctx.fillRect(p.x-2, botY, pipeW+4, 8);
      }
    }
  }

  function drawBird(){
    ctx.save(); ctx.translate(bird.x, bird.y);
    let tilt = Math.max(-0.6, Math.min(0.6, bird.vy/10));
    ctx.rotate(tilt);

    if (SPRITES.birdReady){
      let w = (bird.r*2)*BIRD_SCALE, h = w;
      ctx.drawImage(SPRITES.bird, -w/2, -h/2, w, h);
    } else {
      // simple brand marker
      ctx.fillStyle = BRAND_GOLD;
      ctx.beginPath(); ctx.arc(0,0,bird.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = BRAND_BLUE;
      ctx.beginPath(); ctx.arc(bird.r*0.6,0, bird.r*0.25, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawHUD(){
    // Score box
    ctx.fillStyle = 'rgba(0,0,0,.08)';
    ctx.fillRect(8,8,190,58);
    ctx.fillStyle = INK;
    ctx.font = 'bold 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Score: '+score, 16, 32);
    ctx.fillText('Best:  '+best, 16, 56);

    // Hint when degree is out
    if (degreeSpawned && !won && alive){
      ctx.textAlign = 'center';
      ctx.fillStyle = BRAND_BLUE;
      ctx.font = 'bold 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('üéì Grab your degree!', W/2, 36);
      ctx.textAlign = 'left';
    }

    // Start screen
    if(!started){
      ctx.fillStyle = 'rgba(255,255,255,.75)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = INK;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 26px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Welcome to Pathy Finder!', W/2, H/2 - 36);
      ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Follow the path through campus!', W/2, H/2 - 6);
      ctx.fillStyle = BRAND_BLUE;
      ctx.fillText('Tap / Click / Space to start', W/2, H/2 + 24);
      ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
    }

    // End screens
    if(!alive){
      ctx.fillStyle = 'rgba(255,255,255,.82)';
      ctx.fillRect(0,0,W,H);

      if (won) { drawConfetti(); }

      ctx.fillStyle = INK;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

      if (won) {
        ctx.font = 'bold 30px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('üéì Degree Earned!', W/2, H/2 - 70);

        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        const lines = ["You navigated the whole path.", "Pathfinder would be proud!"];
        const lh = 26;
        lines.forEach((t,i)=> ctx.fillText(t, W/2, H/2 - 24 + i*lh));
      } else {
        ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('Try again!', W/2, H/2 - 70);
        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        const lines = ["Every attempt is practice.", "You‚Äôve got this!"];
        const lh = 26;
        lines.forEach((t,i)=> ctx.fillText(t, W/2, H/2 - 24 + i*lh));
      }

      ctx.fillStyle = BRAND_BLUE;
      ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Press Enter or click Restart', W/2, H/2 + 84);

      ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawFloor();
    if(PATH_ENABLED) drawPath();
    drawPipes();
    drawDegree(); // above pipes so it's visible
    drawBird();
    drawHUD();
  }

  function loop(){ update(); render(); requestAnimationFrame(loop); }

  // Input
  function onKey(e){
    let code = e.code || e.key;
    if(code==='Space'){ e.preventDefault(); flap(); }
    else if(code==='ArrowUp'){ flap(); }
    else if(code==='Enter'){ if(!alive){ reset(); } }
  }
  function onPointer(){ if(alive){ flap(); } }

  document.addEventListener('keydown', onKey);
  canvas.addEventListener('pointerdown', onPointer);
  document.getElementById('flapBtn')?.addEventListener('click', flap);
  document.getElementById('restartBtn')?.addEventListener('click', reset);
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ started=false; } });

  // go
  reset();
  loop();
});
  </script>
</body>
</html>
