<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Variable Tamer ‚Äî xÃÑ rescues Œº</title>
  <!-- Brand stylesheet (placed in /style/bctcstyle.css). If this page lives in /game/, switch to ../style/bctcstyle.css -->
  <link id="brandcss" rel="stylesheet" href="style/bctcstyle.css" />
  <style>
    /* Layout (brand colors/typography from bctcstyle.css) */
    .layout{ display:grid; grid-template-columns: var(--sidebar-w,280px) 1fr; min-height:100dvh }
    @media (max-width:760px){ .layout{ grid-template-columns:1fr } }
    main{ padding:24px; max-width:1100px }

    .feedback{ margin-top:.75rem; padding:.9rem; border-radius:10px; border:1px solid var(--rule); background: var(--panel) }
    .ok{ background: rgba(34,197,94,.10) }
    .bad{ background: rgba(239,68,68,.10) }
    .options{ display:flex; flex-wrap:wrap; gap:.5rem; margin-top:.25rem }
    .pill{ padding:.5rem .75rem; border-radius:999px; border:1px solid var(--rule); cursor:pointer; user-select:none; background:transparent }
    .pill[aria-pressed="true"]{ outline:2px solid var(--kctcs-blue) }

    /* Overworld */
    .field{
      position:relative; height:clamp(200px, 35vh, 320px);
      overflow:hidden; background:var(--panel); border:1px solid var(--rule);
      display:grid; grid-template-columns:repeat(16, 1fr); grid-template-rows:repeat(10, 1fr)
    }
    .tile{ border:1px solid rgba(0,0,0,.04) }
    .grass{ background: linear-gradient(135deg, rgba(46,160,67,.18), rgba(46,160,67,.10)) }
    .path{ background: linear-gradient(135deg, rgba(140,95,60,.18), rgba(140,95,60,.10)) }

    .hero{ position:absolute; display:grid; place-items:center; transition: transform .12s ease; will-change: transform }
    .hero .glyph{ font-weight:900; font-size:18px; line-height:1 }

    .toast{ position:absolute; left:50%; top:8px; transform:translateX(-50%); background: var(--card); border:2px solid var(--kctcs-gold); padding:6px 10px; border-radius:10px; box-shadow:var(--shadow-2); font-weight:700 }

    /* Encounter FX (~2s) */
    .encounter-overlay{ position:absolute; inset:0; pointer-events:none; display:grid; place-items:center; overflow:hidden }
    .encounter-flash{ position:absolute; inset:0; background:radial-gradient(circle at center, rgba(231,166,20,.35), rgba(231,166,20,0) 60%); animation: flash 2000ms ease-out forwards }
    .encounter-stripes{ position:absolute; inset:-20%; background:repeating-linear-gradient(45deg, rgba(0,70,127,.15) 0 14px, rgba(231,166,20,.18) 14px 28px); filter: blur(2px); animation: spin 2000ms linear forwards }
    .shake{ animation: shake 2000ms ease-in-out }
    @keyframes flash{ from{opacity:0} 30%{opacity:1} to{opacity:0} }
    @keyframes spin{ from{ transform: rotate(0deg) scale(1.1) } to{ transform: rotate(8deg) scale(1.05) } }
    @keyframes shake{ 0%,100%{ transform: translate(0,0) } 20%{ transform: translate(-3px, 1px) } 40%{ transform: translate(3px, -1px) } 60%{ transform: translate(-2px, 2px) } 80%{ transform: translate(2px, -2px) } }

    /* Win FX (confetti ~2s) */
    .confetti{ position:fixed; inset:0; pointer-events:none; overflow:hidden }
    .confetti i{ position:absolute; width:10px; height:16px; background: var(--kctcs-gold); transform: rotate(15deg); animation: fall 2000ms ease-in forwards; opacity:.95 }
    .confetti i.alt{ background: var(--kctcs-blue) }
    @keyframes fall{ from{ transform: translateY(-20vh) rotate(0deg) } to{ transform: translateY(110vh) rotate(360deg) } }

    /* Œº cage */
    .muCage{ position:absolute; width:24px; height:24px; display:grid; place-items:center }
    .muCage .mu{ font-size:18px; font-weight:900 }
    .muCage .bars{ position:absolute; inset:0; display:grid; grid-template-columns: repeat(3, 1fr) }
    .muCage .bars i{ background: rgba(0,0,0,.28); margin:1px; border-radius:2px }
    .muCage.free .bars{ animation: barsOpen .7s ease forwards }
    .muCage .mu.muFly{ animation: muFly 1.1s ease-out forwards }
    @keyframes barsOpen{ to{ transform: translateY(-120%); opacity:0 } }
    @keyframes muFly{ to{ transform: translateY(-80px) scale(1.1); opacity:0 } }

    /* BATTLE OVERLAY (slides up) */
    .battle{ position:fixed; inset:0; display:grid; place-items:end center; pointer-events:none; }
    .battle .panel{
      width: min(980px, 100%);
      background: var(--card);
      border-top: 4px solid var(--kctcs-gold);
      box-shadow: 0 -10px 30px rgba(0,0,0,.18);
      transform: translateY(100%);
      transition: transform .45s cubic-bezier(.2,.9,.2,1);
      pointer-events:auto;
      border-radius: 16px 16px 0 0;
      padding: 14px;
      max-height: 92vh; overflow:auto;
    }
    .battle.open .panel{ transform: translateY(0) }
    .battle-hud{ display:grid; grid-template-columns:1fr 1fr; gap:12px; align-items:center; margin-bottom:10px }
    .hud-row{ display:flex; gap:10px; align-items:center; justify-content:space-between; font-weight:700 }

    /* HP bars + numbers */
    .hpwrap{ display:flex; align-items:center; gap:8px; min-width:240px }
    .hpnum{ font-weight:800; font-variant-numeric: tabular-nums; color: var(--muted) }
    .hpbar{ height:14px; background:#eef2f7; border-radius:999px; overflow:hidden; border:1px solid var(--rule); flex:1 }
    .hpfill{ height:100%; width:100%; background:linear-gradient(90deg,#22c55e,#16a34a); transition: width .25s ease }
    .hpfill.enemy{ background:linear-gradient(90deg,#ef4444,#b91c1c) }
    .hpfill.med{ background:linear-gradient(90deg,#f59e0b,#d97706) }
    .hpfill.low{ background:linear-gradient(90deg,#ef4444,#b91c1c) }
    .hpbar.shake{ animation: hpShake 250ms ease }
    @keyframes hpShake { 0%,100% { transform: translateX(0) } 25% { transform: translateX(-2px) } 75% { transform: translateX(2px) } }

    .sprite-stage{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; align-items:center; margin-bottom:10px }
    .sprite{ height:120px; border:1px solid var(--rule); border-radius:12px; display:grid; place-items:center; background:var(--panel); position:relative }
    .sprite .me{ font-weight:900; font-size:28px }
    .sprite .enemyTag{ font-weight:800; font-size:14px; color:var(--muted); position:absolute; top:6px; right:10px }
    .sprite .miniHp { position:absolute; left:8px; right:8px; top:6px; height:6px; border-radius:999px; background:#eef2f7; border:1px solid var(--rule); overflow:hidden; }
    .sprite .miniFill { height:100%; width:100%; background:#22c55e }
    .sprite.enemy .miniFill { background:#ef4444 }

    /* Creature styles */
    .creature{ width:84px; height:84px; position:relative }
    .labelon{ border-radius:26px; background:conic-gradient(from 0deg, #e7a614, #00467f, #8b5cf6, #e7a614); filter:saturate(1.2); animation: morph 2.8s ease-in-out infinite alternate }
    @keyframes morph{ to{ border-radius:14px; transform: rotate(6deg) scale(1.06) } }
    .countaur{ display:grid; grid-template-rows:repeat(3,1fr); gap:4px }
    .countaur i{ background:#0ea5e9; border-radius:6px; width:100%; height:100% }
    .flowdon{ background: radial-gradient(120% 80% at 50% 0%, rgba(0,70,127,.25), transparent), linear-gradient(135deg,#60a5fa,#34d399); border-radius:18px; filter: saturate(1.1); animation: wave 3s ease-in-out infinite }
    @keyframes wave{ 50%{ transform: translateY(-4px) scale(1.02) } }

    .step-title{ font-weight:800; margin:8px 0 4px; color:var(--kctcs-blue) }
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap }
    .battle-msg{ font-size:14px; color:var(--muted); margin:.25rem 0 .5rem }

    /* Damage floaters */
    .floater{
      position:absolute; left:50%; transform:translate(-50%, 0);
      font-weight:900; font-size:16px;
      color:#ef4444; text-shadow:0 1px 0 #fff, 0 0 6px rgba(239,68,68,.35);
      animation: pop 900ms ease-out forwards;
      pointer-events:none;
    }
    .floater.me{ color:#ef4444 }
    .floater.enemy{ color:#ef4444 }
    @keyframes pop{
      0%{ opacity:0; transform:translate(-50%, 10px) scale(.9) }
      15%{ opacity:1; transform:translate(-50%, 0) scale(1) }
      100%{ opacity:0; transform:translate(-50%, -28px) scale(1.06) }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside id="sidebarMount" class="sidebar"></aside>
    <main>
      <header class="header">
        <h1>Variable Tamer</h1>
        <p class="text-muted">Walk around as <strong>xÃÑ</strong> to find a random encounter, then battle in the popup: <strong>Type ‚Üí Level ‚Üí Graphs</strong>. Rescue <strong>Œº</strong> by winning 3 encounters.</p>
      </header>

      <!-- Playfield / Overworld -->
      <section class="panel pad" id="overworld" aria-label="Overworld">
        <div class="row" style="align-items:center; margin-bottom:8px">
          <div class="checkline"><input id="encOn" type="checkbox" checked><label for="encOn"> Random encounters</label></div>
          <div class="text-muted">Use arrow keys / WASD to move. Step in tall grass for encounters.</div>
          <div id="muCounter" class="brand-blue" style="margin-left:auto"><strong>Rescue Œº:</strong> <span id="muCount">0</span>/3</div>
        </div>
        <div id="field" class="field round shadow-1" tabindex="0" role="application" aria-label="Overworld field"></div>
      </section>
    </main>
  </div>

  <!-- Battle Overlay (ALL questions live here) -->
  <div id="battle" class="battle" aria-hidden="true">
    <div class="panel">
      <div class="battle-hud">
        <div class="hud-row">
          <span>üßë‚Äçüè´ xÃÑ</span>
          <div class="hpwrap">
            <div class="hpbar" id="hpMeBar" aria-label="Player HP">
              <div id="hpMeFill" class="hpfill"></div>
            </div>
            <div id="hpMeNum" class="hpnum">100/100</div>
          </div>
        </div>
        <div class="hud-row">
          <span id="enemyName">Enemy</span>
          <div class="hpwrap">
            <div class="hpbar" id="hpEnemyBar" aria-label="Enemy HP">
              <div id="hpEnemyFill" class="hpfill enemy"></div>
            </div>
            <div id="hpEnemyNum" class="hpnum">100/100</div>
          </div>
        </div>
      </div>

      <div class="sprite-stage">
        <div id="spriteMe" class="sprite">
          <div class="miniHp"><div id="miniMe" class="miniFill"></div></div>
          <div class="me">xÃÑ</div>
        </div>
        <div id="spriteEnemy" class="sprite enemy">
          <div class="miniHp"><div id="miniEnemy" class="miniFill"></div></div>
          <div id="enemyTag" class="enemyTag"></div>
          <div id="enemySprite" class="creature"></div>
        </div>
      </div>

      <div class="battle-msg" id="battleMsg">A wild variable challenges you!</div>

      <!-- STEP 1: TYPE -->
      <div class="card" id="bStepType">
        <div class="step-title">1) Variable Type</div>
        <div class="row">
          <select id="bTypeSelect">
            <option value="">‚Äî choose ‚Äî</option>
            <option value="categorical">Categorical (Qualitative)</option>
            <option value="quant_discrete">Quantitative ‚Äî Discrete</option>
            <option value="quant_continuous">Quantitative ‚Äî Continuous</option>
          </select>
          <button class="btn" id="bSubmitType">Submit</button>
          <button class="btn ghost" id="bHintType">Hint</button>
        </div>
        <div id="bFbType"></div>
      </div>

      <!-- STEP 2: LEVEL -->
      <div class="card" id="bStepLevel" style="display:none">
        <div class="step-title">2) Level of Measurement</div>
        <div class="row">
          <select id="bLevelSelect">
            <option value="">‚Äî choose ‚Äî</option>
            <option value="nominal">Nominal</option>
            <option value="ordinal">Ordinal</option>
            <option value="interval">Interval</option>
            <option value="ratio">Ratio</option>
          </select>
          <button class="btn" id="bSubmitLevel">Submit</button>
          <button class="btn ghost" id="bHintLevel">Hint</button>
        </div>
        <div id="bFbLevel"></div>
      </div>

      <!-- STEP 3: GRAPHS -->
      <div class="card" id="bStepGraphs" style="display:none">
        <div class="step-title">3) Choose all appropriate graph types</div>
        <div class="options" id="bGraphOptions" role="group" aria-label="Graph choices"></div>
        <div class="row" style="margin-top:.6rem">
          <button class="btn" id="bSubmitGraphs">Submit</button>
          <button class="btn ghost" id="bHintGraphs">Hint</button>
        </div>
        <div id="bFbGraphs"></div>
      </div>

      <details class="panel pad" id="bExplainBox" style="margin-top:.6rem; display:none">
        <summary>Explanation</summary>
        <div id="bExplain"></div>
      </details>

      <div class="row" style="margin-top:10px; justify-content:flex-end">
        <button class="btn outline" id="bClose" title="Close battle (dev helper)">Close</button>
      </div>
    </div>
  </div>

  <script>
  // Sidebar + CSS fallback
  (async function(){
    try{
      const res = await fetch('partials/sidebar.html', {cache:'no-store'});
      if(res.ok){ const m=document.getElementById('sidebarMount'); if(m) m.innerHTML = await res.text(); }
    }catch(_){ /* ignore */ }
    const rootStyle = getComputedStyle(document.documentElement);
    if(!rootStyle.getPropertyValue('--kctcs-blue').trim()){
      const link = document.getElementById('brandcss'); if(link) link.href = '../style/bctcstyle.css';
    }
  })();

  // OVERWORLD (xÃÑ + Œº + encounters)
  const field = document.getElementById('field');
  const encOn = document.getElementById('encOn');
  const COLS=16, ROWS=10;
  let grid=[]; let hero={x:8,y:5,el:null};
  let mu={x:12,y:3,el:null,caged:true,progress:0};

  function buildField(){
    if(!field) return;
    field.innerHTML=''; grid=[];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const d=document.createElement('div'); d.className='tile';
        const isGrass = (r>1 && r<ROWS-1 && c>1 && c<COLS-1 && Math.random()<0.6);
        d.classList.add(isGrass? 'grass':'path');
        field.appendChild(d);
        grid.push(isGrass? 'G':'P');
      }
    }
    const h=document.createElement('div');
    h.className='hero'; h.innerHTML='<span class="glyph">xÃÑ</span>';
    field.appendChild(h); hero.el=h; placeHero(true);
    if(mu.caged){
      const m=document.createElement('div'); m.className='muCage'; m.innerHTML='<span class="mu">Œº</span><div class="bars"><i></i><i></i><i></i></div>';
      field.appendChild(m); mu.el=m; placeMu();
    }
  }
  function cellSize(){ return { cw: field.clientWidth/COLS, ch: field.clientHeight/ROWS }; }
  function resizeField(){
    if(!field) return; const cell = field.clientWidth / COLS;
    field.style.height = (cell * ROWS) + 'px';
    placeHero(true); placeMu();
  }
  function placeHero(resize=false){
    if(!hero.el) return; const {cw,ch}=cellSize();
    if(resize){ hero.el.style.width=`${cw}px`; hero.el.style.height=`${ch}px`; }
    hero.el.style.transform=`translate(${hero.x*cw}px, ${hero.y*ch}px)`;
  }
  function placeMu(){ if(!mu.el) return; const {cw,ch}=cellSize(); mu.el.style.transform=`translate(${mu.x*cw}px, ${mu.y*ch}px)`; }
  function tileAt(x,y){ if(x<0||y<0||x>=COLS||y>=ROWS) return 'W'; return grid[y*COLS+x]; }
  function tryMove(dx,dy){ const nx=hero.x+dx, ny=hero.y+dy; if(tileAt(nx,ny)==='W') return; hero.x=nx; hero.y=ny; placeHero(); placeMu(); maybeEncounter(); }
  function maybeEncounter(){
    if(!encOn || !encOn.checked) return;
    if(tileAt(hero.x,hero.y)!=='G') return;
    if(Math.random()<0.20){ showToast('A wild variable appears!'); startEncounter(); }
  }
  function showToast(msg){ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; field.appendChild(t); setTimeout(()=>t.remove(),1200); }
  function updateMuCounter(){ const c=document.getElementById('muCount'); if(c) c.textContent = String(mu.progress); }
  function progressMu(){ if(!mu.caged) return; mu.progress++; updateMuCounter(); if(mu.progress>=3) freeMu(); }
  function freeMu(){ if(!mu.el) return; mu.el.classList.add('free'); const span = mu.el.querySelector('.mu'); if(span) span.classList.add('muFly'); setTimeout(()=>{ mu.el.remove(); mu.caged=false; showToast('Œº is free!'); }, 1100); }

  // Encounter/Win FX
  function playEncounterFX(){
    if(!field) return;
    const ov = document.createElement('div'); ov.className='encounter-overlay';
    const stripes = document.createElement('div'); stripes.className='encounter-stripes';
    const flash = document.createElement('div'); flash.className='encounter-flash';
    ov.appendChild(stripes); ov.appendChild(flash); field.appendChild(ov);
    field.classList.add('shake');
    setTimeout(()=>{ field.classList.remove('shake'); ov.remove(); }, 2100);
  }
  function playWinFX(){
    const layer = document.createElement('div'); layer.className='confetti';
    const n = 50; const w = window.innerWidth; const h = window.innerHeight;
    for(let i=0;i<n;i++){
      const p = document.createElement('i');
      p.style.left = (Math.random()*w) + 'px';
      p.style.top = (-Math.random()*h*0.3) + 'px';
      p.style.opacity = 0.8 + Math.random()*0.2;
      p.style.transform = `rotate(${Math.random()*180}deg)`;
      if(i%3===0) p.classList.add('alt');
      p.style.animationDelay = (Math.random()*0.2)+'s';
      layer.appendChild(p);
    }
    document.body.appendChild(layer);
    setTimeout(()=> layer.remove(), 2100);
  }

  // ======== BATTLE SYSTEM (popup) ========
  const battleEl = document.getElementById('battle');
  const hpMeFill = document.getElementById('hpMeFill');
  const hpEnemyFill = document.getElementById('hpEnemyFill');
  const hpMeBar = document.getElementById('hpMeBar');
  const hpEnemyBar = document.getElementById('hpEnemyBar');
  const hpMeNum = document.getElementById('hpMeNum');
  const hpEnemyNum = document.getElementById('hpEnemyNum');
  const miniMe = document.getElementById('miniMe');
  const miniEnemy = document.getElementById('miniEnemy');

  const enemyNameEl = document.getElementById('enemyName');
  const enemyTagEl = document.getElementById('enemyTag');
  const enemySpriteEl = document.getElementById('enemySprite');
  const battleMsgEl = document.getElementById('battleMsg');
  const spriteMe = document.getElementById('spriteMe');
  const spriteEnemy = document.getElementById('spriteEnemy');

  // Battle step DOM
  const bStepType = document.getElementById('bStepType');
  const bStepLevel = document.getElementById('bStepLevel');
  const bStepGraphs = document.getElementById('bStepGraphs');
  const bTypeSelect = document.getElementById('bTypeSelect');
  const bLevelSelect = document.getElementById('bLevelSelect');
  const bGraphOptions = document.getElementById('bGraphOptions');
  const bFbType = document.getElementById('bFbType');
  const bFbLevel = document.getElementById('bFbLevel');
  const bFbGraphs = document.getElementById('bFbGraphs');
  const bExplainBox = document.getElementById('bExplainBox');
  const bExplain = document.getElementById('bExplain');
  const bClose = document.getElementById('bClose');

  const CREATURES = {
    categorical: { name:'Labelon', build: (el)=>{ el.className='creature labelon'; el.innerHTML=''; } },
    quant_discrete: { name:'Countaur', build: (el)=>{ el.className='creature countaur'; el.innerHTML='<i></i><i></i><i></i>'; } },
    quant_continuous: { name:'Flowdon', build: (el)=>{ el.className='creature flowdon'; el.innerHTML=''; } },
  };

  /* Creature one-liners (correct/wrong pools) */
  const CREATURE_LINES = {
    categorical: {
      correct:[
        "Labelon: ‚ÄúNames only‚Äîno numbers needed!‚Äù",
        "Labelon: ‚ÄúQualitative and proud!‚Äù",
        "Labelon: ‚ÄúLabels rule, order drools!‚Äù"
      ],
      wrong:[
        "Labelon: ‚ÄúTrying to rank me? Hah!‚Äù",
        "Labelon: ‚ÄúNumbers? Not in this house.‚Äù",
        "Labelon: ‚ÄúNo inherent order‚Äîgotcha!‚Äù"
      ]
    },
    quant_discrete: {
      correct:[
        "Countaur: ‚ÄúClop! Integer steps only.‚Äù",
        "Countaur: ‚ÄúCounts click like dice.‚Äù",
        "Countaur: ‚ÄúDiscrete wins‚Äîno in-betweens.‚Äù"
      ],
      wrong:[
        "Countaur: ‚ÄúYou can‚Äôt split a count!‚Äù",
        "Countaur: ‚ÄúHalf a sibling? Neigh!‚Äù",
        "Countaur: ‚ÄúDiscrete ‚â† continuous, friend.‚Äù"
      ]
    },
    quant_continuous: {
      correct:[
        "Flowdon: ‚ÄúI flow between any two points.‚Äù",
        "Flowdon: ‚ÄúInfinite granularity‚Ä¶ smooth!‚Äù",
        "Flowdon: ‚ÄúContinuum conquered.‚Äù"
      ],
      wrong:[
        "Flowdon: ‚ÄúDon‚Äôt box me into integers!‚Äù",
        "Flowdon: ‚ÄúI‚Äôm smoother than that.‚Äù",
        "Flowdon: ‚ÄúBetween any two, there‚Äôs more!‚Äù"
      ]
    }
  };

  /* Only 4 graph choices now */
  const GRAPH_CHOICES = [
    { id:"bar",  label:"Bar chart" },
    { id:"pie",  label:"Pie chart" },
    { id:"hist", label:"Histogram" },
    { id:"box",  label:"Box plot" },
  ];

  /* Damage & HP */
  const DAMAGE_ENEMY = 34;   // ~3 hits
  const DAMAGE_ME = 15;
  const MAX_ME = 100, MAX_ENEMY = 100;
  let hpMeVal = MAX_ME, hpEnemyVal = MAX_ENEMY;

  let current = null;
  let step = 1; // 1,2,3

  function setHP(fillEl, numEl, barEl, miniEl, val, max){
    const pct = Math.max(0, Math.min(100, (val/max)*100));
    fillEl.style.width = pct + '%';
    if (numEl) numEl.textContent = `${val}/${max}`;

    // color states
    fillEl.classList.remove('med','low');
    if (pct <= 35) fillEl.classList.add('low');
    else if (pct <= 65) fillEl.classList.add('med');

    // shake on change
    if (barEl){
      barEl.classList.remove('shake'); void barEl.offsetWidth; barEl.classList.add('shake');
      setTimeout(()=> barEl.classList.remove('shake'), 260);
    }

    if (miniEl) miniEl.style.width = pct + '%';
  }
  function refreshAllHP(){
    setHP(hpMeFill, hpMeNum, hpMeBar, miniMe, hpMeVal, MAX_ME);
    setHP(hpEnemyFill, hpEnemyNum, hpEnemyBar, miniEnemy, hpEnemyVal, MAX_ENEMY);
  }

  function openBattle(type, prompt){
    const c = CREATURES[type] || CREATURES.categorical;
    enemyNameEl.textContent = c.name;
    enemyTagEl.textContent = type.replace('_',' ');
    c.build(enemySpriteEl);
    hpMeVal = MAX_ME; hpEnemyVal = MAX_ENEMY; refreshAllHP();
    battleMsgEl.innerHTML = `<strong>A wild variable appears:</strong> ${prompt}`;
    // reset steps
    step=1;
    bTypeSelect.value=''; bLevelSelect.value='';
    bFbType.innerHTML=''; bFbLevel.innerHTML=''; bFbGraphs.innerHTML='';
    bExplain.textContent=''; bExplainBox.style.display='none';
    bGraphOptions.innerHTML=''; renderGraphPills();
    setBattleScreen(1);
    battleEl.classList.add('open'); battleEl.setAttribute('aria-hidden','false');
  }
  function closeBattle(){
    battleEl.classList.remove('open');
    battleEl.setAttribute('aria-hidden','true');
  }
  function setBattleScreen(n){
    step=n;
    bStepType.style.display = (n===1?'':'none');
    bStepLevel.style.display = (n===2?'':'none');
    bStepGraphs.style.display = (n===3?'':'none');
  }
  function setFeedback(el, ok, html){
    const div=document.createElement('div'); div.className=`feedback ${ok?'ok':'bad'}`; div.innerHTML=html; el.innerHTML=''; el.appendChild(div);
  }

  /* ---- Damage + Floaters + Lines ---- */
  function randomLine(type, ok){
    const t = CREATURE_LINES[type] || CREATURE_LINES.categorical;
    const pool = ok ? t.correct : t.wrong;
    return pool[Math.floor(Math.random()*pool.length)];
  }
  function floater(targetEl, text){
    if(!targetEl) return;
    const f = document.createElement('div');
    f.className = `floater`;
    f.textContent = text;
    targetEl.appendChild(f);
    const jitter = (Math.random()*24 - 12);
    f.style.left = `calc(50% + ${jitter}px)`;
    setTimeout(()=>{ f.remove(); }, 950);
  }

  function damageEnemy(){
    hpEnemyVal = Math.max(0, hpEnemyVal - DAMAGE_ENEMY);
    refreshAllHP();
    floater(spriteEnemy, `‚àí${DAMAGE_ENEMY}`);
    if(hpEnemyVal<=0){ onWinBattle(); }
  }
  function damageMe(){
    hpMeVal = Math.max(0, hpMeVal - DAMAGE_ME);
    refreshAllHP();
    floater(spriteMe, `‚àí${DAMAGE_ME}`);
    if(hpMeVal<=0){ onLoseBattle(); }
  }
  function sayCreature(ok){
    const t = current.type;
    battleMsgEl.textContent = randomLine(t, ok);
  }

  function onWinBattle(){
    battleMsgEl.textContent = 'Victory! The variable is tamed.';
    playWinFX(); progressMu(); updateMuCounter();
    setTimeout(()=> closeBattle(), 1200);
  }
  function onLoseBattle(){
    battleMsgEl.textContent = 'xÃÑ lost confidence and recalculates‚Ä¶';
    setTimeout(()=>{ closeBattle(); }, 1200);
  }

  // BANK (graphs restricted to {bar, pie, hist, box})
  const BANK = [
    // Categorical ‚Äî nominal: Bar, Pie
    {prompt:"Favorite ice cream flavor", type:"categorical", level:"nominal", graphs:["bar","pie"], why:"Categories without order ‚áí nominal. Bar or pie both OK."},
    {prompt:"Jersey number", type:"categorical", level:"nominal", graphs:["bar","pie"], why:"Identifiers/labels ‚áí nominal."},
    {prompt:"Month of birth", type:"categorical", level:"nominal", graphs:["bar","pie"], why:"No inherent linear order."},
    {prompt:"Handedness (left/right)", type:"categorical", level:"nominal", graphs:["bar","pie"], why:"Binary categories ‚áí nominal."},

    // Categorical ‚Äî ordinal: Bar only to reinforce ordering
    {prompt:"Class standing (freshman, sophomore, junior, senior)", type:"categorical", level:"ordinal", graphs:["bar"], why:"Ordered categories ‚áí bar chart (sorted order)."},
    {prompt:"Finishing position in a race (1st, 2nd, 3rd, ‚Ä¶)", type:"categorical", level:"ordinal", graphs:["bar"], why:"Ranks ‚áí ordinal; bar chart communicates order."},
    {prompt:"Satisfaction (Likert: 1‚Äì5)", type:"categorical", level:"ordinal", graphs:["bar"], why:"Likert items are ordinal; use bar to show order."},
    {prompt:"Class period (1st, 2nd, ‚Ä¶)", type:"categorical", level:"ordinal", graphs:["bar"], why:"Ordered labels ‚áí bar chart works best."},

    // Quantitative ‚Äî use Histogram and/or Box plot
    {prompt:"Number of siblings", type:"quant_discrete", level:"ratio", graphs:["hist","box"], why:"Counts (discrete ratio). Histogram or box plot."},
    {prompt:"Daily step count", type:"quant_discrete", level:"ratio", graphs:["hist","box"], why:"Counts ‚áí discrete; histogram/box are appropriate."},
    {prompt:"Shots made out of 10 attempts", type:"quant_discrete", level:"ratio", graphs:["hist","box"], why:"Counts (binomial). Histogram/box."},

    {prompt:"Weekly study hours", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"Time is continuous ratio. Histogram/box plot."},
    {prompt:"Height (cm)", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"Continuous ratio variable. Histogram/box."},
    {prompt:"Age (years)", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"True zero; histogram/box fit."},
    {prompt:"Exam score (0‚Äì100)", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"Treated like ratio; histogram/box."},
    {prompt:"Distance (meters)", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"Physical measure (true zero)."},
    {prompt:"Finish time in 5K (minutes)", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"Time (ratio). Histogram/box."},

    // Interval scale (still quantitative): Histogram/Box
    {prompt:"Body temperature (¬∞C)", type:"quant_continuous", level:"interval", graphs:["hist","box"], why:"Interval scale ‚áí histogram or box."},
    {prompt:"Temperature (¬∞F)", type:"quant_continuous", level:"interval", graphs:["hist","box"], why:"Interval scale ‚áí histogram/box."},
    {prompt:"Temperature change from baseline (Œî¬∞C)", type:"quant_continuous", level:"interval", graphs:["hist","box"], why:"Differences can be negative; histogram/box."},

    // Kelvin: ratio
    {prompt:"Body temperature (K)", type:"quant_continuous", level:"ratio", graphs:["hist","box"], why:"Kelvin has a true zero ‚áí ratio. Histogram/box."},
  ];

  function pickNew(){
    current = BANK[Math.floor(Math.random()*BANK.length)];
    openBattle(current.type, current.prompt);
  }

  // Graph pills in popup (only 4)
  function renderGraphPills(){
    GRAPH_CHOICES.forEach((g, idx)=>{
      const btn = document.createElement('button');
      btn.className='pill'; btn.type='button';
      btn.setAttribute('role','switch'); btn.setAttribute('aria-pressed','false');
      btn.dataset.id = g.id; btn.textContent = `${idx+1}. ${g.label}`;
      btn.addEventListener('click', ()=>{
        const on = btn.getAttribute('aria-pressed')==='true';
        btn.setAttribute('aria-pressed', String(!on));
      });
      bGraphOptions.appendChild(btn);
    });
  }
  function getSelectedGraphs(){
    return [...bGraphOptions.children].filter(x=>x.getAttribute('aria-pressed')==='true').map(x=>x.dataset.id);
  }
  function prettyType(t){
    return t==='categorical' ? 'Categorical (Qualitative)'
      : t==='quant_discrete' ? 'Quantitative ‚Äî Discrete'
      : 'Quantitative ‚Äî Continuous';
  }
  function prettyLevel(l){ return l[0].toUpperCase()+l.slice(1); }
  function prettyGraph(id){ const f = GRAPH_CHOICES.find(g=>g.id===id); return f? f.label : id; }
  function arraysEqualAsSets(a,b){ if (a.length!==b.length) return false; const A=[...a].sort(), B=[...b].sort(); return A.every((v,i)=>v===B[i]); }

  // Submit handlers (popup)
  document.getElementById('bSubmitType').addEventListener('click', ()=>{
    const ans = bTypeSelect.value;
    if(!ans){ setFeedback(bFbType,false,'Pick a type.'); return; }
    if(ans===current.type){
      setFeedback(bFbType,true,'Correct! Attack landed.');
      damageEnemy(); sayCreature(true); setBattleScreen(2);
    } else {
      setFeedback(bFbType,false,`Not quite. This variable is <b>${prettyType(current.type)}</b>. You take damage.`);
      damageMe(); sayCreature(false);
    }
  });
  document.getElementById('bSubmitLevel').addEventListener('click', ()=>{
    const ans = bLevelSelect.value;
    if(!ans){ setFeedback(bFbLevel,false,'Pick a level.'); return; }
    if(ans===current.level){
      setFeedback(bFbLevel,true,'Correct! Attack landed.');
      damageEnemy(); sayCreature(true); setBattleScreen(3);
    } else {
      setFeedback(bFbLevel,false,`Not quite. The level is <b>${prettyLevel(current.level)}</b>. You take damage.`);
      damageMe(); sayCreature(false);
    }
  });
  document.getElementById('bSubmitGraphs').addEventListener('click', ()=>{
    const chosen = getSelectedGraphs();
    if(chosen.length===0){ setFeedback(bFbGraphs,false,'Choose at least one graph type.'); return; }
    const correct = current.graphs;
    if(arraysEqualAsSets(chosen, correct)){
      setFeedback(bFbGraphs,true,'Perfect! Critical hit ‚Äî variable tamed.');
      bExplain.textContent = current.why; bExplainBox.style.display='block';
      damageEnemy(); sayCreature(true);
      if(hpEnemyVal>0){ playWinFX(); progressMu(); updateMuCounter(); }
    } else {
      setFeedback(bFbGraphs,false,`Close. Correct set: <b>${correct.map(prettyGraph).join(', ')}</b>. You take damage.`);
      damageMe(); sayCreature(false);
    }
  });

  // Hints
  document.getElementById('bHintType').addEventListener('click', ()=> setFeedback(bFbType,true,`Hint: ${current.why.split('.')[0]}.`));
  document.getElementById('bHintLevel').addEventListener('click', ()=> setFeedback(bFbLevel,true,`Hint: ${current.why.split('.')[0]}.`));
  document.getElementById('bHintGraphs').addEventListener('click', ()=> setFeedback(bFbGraphs,true,`Appropriate: ${current.graphs.map(prettyGraph).join(', ')}`));

  // Open/Close + Encounter start
  function startEncounter(){
    playEncounterFX();
    setTimeout(()=>{ pickNew(); }, 2000);
  }
  document.getElementById('bClose').addEventListener('click', closeBattle);
  window.addEventListener('keydown',(e)=>{
    const k=e.key.toLowerCase();
    if(['arrowup','w'].includes(k)) { e.preventDefault(); tryMove(0,-1); }
    if(['arrowdown','s'].includes(k)) { e.preventDefault(); tryMove(0,1); }
    if(['arrowleft','a'].includes(k)) { e.preventDefault(); tryMove(-1,0); }
    if(['arrowright','d'].includes(k)) { e.preventDefault(); tryMove(1,0); }
    if(k==='escape' && battleEl.classList.contains('open')){ e.preventDefault(); closeBattle(); }
    if(e.key==='Enter'){
      if(step===1){ document.getElementById('bSubmitType').click(); }
      else if(step===2){ document.getElementById('bSubmitLevel').click(); }
      else { document.getElementById('bSubmitGraphs').click(); }
    }
    if(/^[1-4]$/.test(e.key) && step===3){
      const idx = parseInt(e.key,10)-1; const btn = bGraphOptions.children[idx]; if(btn){ btn.click(); }
    }
  });

  // Build/grid sizing
  buildField(); resizeField(); updateMuCounter();
  window.addEventListener('resize', ()=> requestAnimationFrame(resizeField));
  window.addEventListener('load', resizeField);
  </script>
</body>
</html>
